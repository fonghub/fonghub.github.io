<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>不知有晋</title>
    <meta name="author" content="CFONG">
    
	<meta name="description" content=""> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="不知有晋" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>
    <script src="/javascripts/MathJax.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        不知有晋
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  
  
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="http://chenfeng.org" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        



  <article class="post">
	<h2 class="title">
		<a href="2020/07/30/select-sort/">选择排序——直接选择排序、堆排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-30T05:00:00.000Z" itemprop="datePublished">Jul 30, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>每一趟从待排序的记录中选出关键字最小的记录，顺序放在已排好序的子表的最后，直到全部记录排序完毕。 </p>
<h3><span id="liang-chong-xuan-ze-pai-xu-fang-fa">两种选择排序方法</span><a href="#liang-chong-xuan-ze-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>直接选择排序</li>
<li>堆排序</li>
</ol>
<h3><span id="zhi-jie-xuan-ze-pai-xu">直接选择排序</span><a href="#zhi-jie-xuan-ze-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>设有n个元素，则需要n-1次循环。<br>每次循环通过两两对比，找到关键值最小的记录，经过n-1次循环后则可以得到一个有序的序列。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  R[i]的关键值与R[j]的关键值逐个比较，每次把较小的赋值给R[i]</span></span><br><span class="line">            <span class="comment">//  存在交换多次的问题</span></span><br><span class="line">            <span class="keyword">if</span>(R[i].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[i];</span><br><span class="line">                R[i] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：非稳定</p>
<h3><span id="zhi-jie-xuan-ze-pai-xu-you-hua-ban">直接选择排序 优化版</span><a href="#zhi-jie-xuan-ze-pai-xu-you-hua-ban" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>直接选择排序在每一次找到最小值的过程中，需要进行多次关键值比较。<br>若比较结果成立，则记录的位置互换（执行赋值操作）。<br>例如要求关键字序列：<code>9 8 7 6 5</code> 按递增顺序显示，程序的第一次遍历结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;   9 8 7 6 5 </span><br><span class="line">2&gt;   8 9 7 6 5</span><br><span class="line">3&gt;   7 9 8 6 5</span><br><span class="line">4&gt;   6 9 8 7 5</span><br><span class="line">5&gt;   5 9 8 7 6</span><br></pre></td></tr></table></figure>

<p>很明显，第一次遍历找到的最小值应该是 <code>5</code>，但是找到最小值过程中，发生了多次无用的赋值操作（第2、3、4行）。<br>为了减少时间复杂度，在比较的过程中，使用一个变量保存最小值的索引值，直到与最后一个元素比较后，才执行赋值操作。优化后的程序第一次遍历的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt;   9 8 7 6 5 </span><br><span class="line">2&gt;   5 9 8 7 6</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  选择排序 优化版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  默认第一个元素是最小的</span></span><br><span class="line">        k = i;      </span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(R[k].key &gt; R[j].key)</span><br><span class="line">                k = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  最后做一次比较，不相等则互相交换</span></span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[k];</span><br><span class="line">            R[k] = R[i];</span><br><span class="line">            R[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：非稳定</p>
<h3><span id="zhi-jie-xuan-ze-pai-xu-dai-ma">直接选择排序代码</span><a href="#zhi-jie-xuan-ze-pai-xu-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序 ... \n&quot;</span>);</span><br><span class="line">    SelectSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序 改进版... \n&quot;</span>);</span><br><span class="line">    SelectSort_v2(R,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  R[i]的关键值与R[j]的关键值逐个比较，每次把较小的赋值给R[i]</span></span><br><span class="line">            <span class="comment">//  存在交换多次的问题</span></span><br><span class="line">            <span class="keyword">if</span>(R[i].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[i];</span><br><span class="line">                R[i] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  默认第一个元素是最小的</span></span><br><span class="line">        k = i;      </span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(R[k].key &gt; R[j].key)</span><br><span class="line">                k = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  最后做一次比较，不相等则互相交换</span></span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[k];</span><br><span class="line">            R[k] = R[i];</span><br><span class="line">            R[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="dui-pai-xu">堆排序</span><a href="#dui-pai-xu" class="header-anchor">#</a></h3><p><strong>完全二叉树简介</strong></p>
<p>使用待排序 关键值序列 构建一棵完全二叉树，然后从上到下，从左到右，按顺序给完全二叉树编号。</p>
<blockquote>
<p>使用顺序存储结构，所以物理编号为 $0$ 的位置为空，从物理编号为 $1$ 的位置开始保存关键值。</p>
</blockquote>
<p>根据完全二叉树的性质可知：</p>
<ol>
<li>若编号为 $i$ 的节点为分支节点，则 $2i$ 为左子节点，$2i+1$ 为右子节点；</li>
<li>若编号为 $i$ 的节点有父节点，则父节点编号为 $floor(\frac {i} {2})$ ；</li>
<li>若完全二叉树有 $n$ 个节点，则编号最大的分支节点为 $floor(\frac {n}{2})$ ；</li>
</ol>
<p><strong>堆的定义</strong></p>
<p>$n$ 个关键字序列 $K_1,K_2,…,K_n$ 称为堆，当且仅当该序列满足如下性质：</p>
<ol>
<li>$K_i&lt;&#x3D;K_{2i}$ 且 $K_i&lt;&#x3D;K_{2i+1}$ </li>
<li>或 $K_i&gt;&#x3D;K_{2i}$ 且 $K_i&gt;&#x3D;K_{2i+1}$<br>$(1&lt;&#x3D;i&lt;&#x3D;floor(\frac {n}{2}))$</li>
</ol>
<p>堆可分为小根堆和大根堆：</p>
<ol>
<li>小根堆：根节点关键值 <strong>小于等于</strong> 左右子节点关键值的堆；</li>
<li>大根堆：根节点关键值 <strong>大于等于</strong> 左右子节点关键值的堆；</li>
</ol>
<p><strong>基本思想</strong></p>
<p>从编号最大的分支节点开始（编号为 $floor(\frac {n}{2})$ ），<strong>最大堆化</strong> 每一棵树，直到根节点结束。<br>此时得到一个最大堆，因为最大堆的根节点关键值最大，所以保存根节点，然后使用最有一个叶子节点赋值给根节点，继续堆化，直到最后一个节点结束。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Heapify(R,i,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[j];</span><br><span class="line">        R[j] = R[<span class="number">1</span>];</span><br><span class="line">        R[<span class="number">1</span>] = tmp;</span><br><span class="line">        Heapify(R,<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  最大堆化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    tmp = R[p];</span><br><span class="line">    i = p;</span><br><span class="line">    j = <span class="number">2</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个子节点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  有两个子节点则找到较大的那个</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n &amp;&amp; R[j].key &lt; R[j+<span class="number">1</span>].key) j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  父节点比子节点小，则子节点“上浮”到父节点，并且继续堆化</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(nlog_2n)$</p>
<p>稳定性：非稳定</p>
<h3><span id="dui-pai-xu-wan-zheng-dai-ma">堆排序完整代码</span><a href="#dui-pai-xu-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i+<span class="number">1</span>].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆排序... \n&quot;</span>);</span><br><span class="line">    HeapSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i+<span class="number">1</span>].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Heapify(R,i,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[j];</span><br><span class="line">        R[j] = R[<span class="number">1</span>];</span><br><span class="line">        R[<span class="number">1</span>] = tmp;</span><br><span class="line">        Heapify(R,<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  堆化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    tmp = R[p];</span><br><span class="line">    i = p;</span><br><span class="line">    j = <span class="number">2</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个子节点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  有两个子节点则找到较大的那个</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n &amp;&amp; R[j].key &lt; R[j+<span class="number">1</span>].key) j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  父节点比子节点小，则子节点“上浮”到父节点，并且继续堆化</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/29/swap-sort/">交换排序——冒泡排序、快速排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-29T05:00:00.000Z" itemprop="datePublished">Jul 29, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。 </p>
<h3><span id="liang-chong-jiao-huan-pai-xu-fang-fa">两种交换排序方法</span><a href="#liang-chong-jiao-huan-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>冒泡排序</li>
<li>快速排序</li>
</ol>
<h3><span id="mou-pao-pai-xu">冒泡排序</span><a href="#mou-pao-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>把待排序记录在逻辑上分成有序区和无序区，一开始有序区没有记录，无序区有 $n$ 个记录。</p>
<p>通过无序区中相邻记录关键字间的比较和位置的交换，使关键字最小的记录如气泡一般逐渐往上<strong>漂浮</strong> 直至 <strong>水面</strong>。<br>$n$ 个元素排序，需要 $n-1$ 趟冒泡，有序区逐渐扩大到全局有序。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="mou-pao-pai-xu-you-hua-ban">冒泡排序 优化版</span><a href="#mou-pao-pai-xu-you-hua-ban" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>无序区中记录 <strong>冒泡</strong> 的过程，会逐渐把无序区里的记录变得有序，所以假如有 $n$ 个无序记录，一般情况下不需要 $n-1$ 趟冒泡就可以使全局达到有序。</p>
<p>普通冒泡排序，需要9趟冒泡排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序前：1 4 6 8 0 2 5 7 9 3 </span><br><span class="line">冒泡排序 ... </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">排序后：0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure>

<p>优化版冒泡排序，需要6趟冒泡排序就可以使全局记录有序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序前：1 4 6 8 0 2 5 7 9 3 </span><br><span class="line">冒泡排序 改进版 ... </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">排序后：0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  冒泡排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="kuai-su-pai-xu">快速排序</span><a href="#kuai-su-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>在待排序的 $n$ 个记录中任取一个记录（通常取第一个记录）作为基准，把该记录放入适当位置后，数据序列被此记录划分成两部分，分别是比基准小和比基准大的记录。再对基准两边的序列用同样的策略进行操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  快速排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    RecType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  至少两个元素参与排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一个元素最为基准元素</span></span><br><span class="line">    tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[j].key &gt;= tmp.key)</span><br><span class="line">            j--;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i].key &lt;= tmp.key)</span><br><span class="line">            i++;</span><br><span class="line">        R[j] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  基准元素找到了正确位置</span></span><br><span class="line">    R[i] = tmp;</span><br><span class="line">    QuickSort(R,left,i<span class="number">-1</span>);</span><br><span class="line">    QuickSort(R,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(nlog_2n)$</p>
<p>稳定性：不稳定</p>
<h3><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  交换排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序 ... \n&quot;</span>);</span><br><span class="line">    BubbleSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序 改进版 ... \n&quot;</span>);</span><br><span class="line">    BubbleSort_v2(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;快速排序 ... \n&quot;</span>);</span><br><span class="line">    QuickSort(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  冒泡排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  快速排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    RecType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  至少两个元素参与排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一个元素最为基准元素</span></span><br><span class="line">    tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[j].key &gt;= tmp.key)</span><br><span class="line">            j--;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i].key &lt;= tmp.key)</span><br><span class="line">            i++;</span><br><span class="line">        R[j] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  基准元素找到了正确位置</span></span><br><span class="line">    R[i] = tmp;</span><br><span class="line">    QuickSort(R,left,i<span class="number">-1</span>);</span><br><span class="line">    QuickSort(R,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/28/insert-sort/">插入排序——直接插入排序、希尔排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-28T05:00:00.000Z" itemprop="datePublished">Jul 28, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子表中的适当位置，直到全部记录插入完成为止。</p>
<h3><span id="liang-chong-cha-ru-pai-xu-fang-fa">两种插入排序方法</span><a href="#liang-chong-cha-ru-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>直接插入排序</li>
<li>希尔排序</li>
</ol>
<h3><span id="zhi-jie-cha-ru-pai-xu">直接插入排序</span><a href="#zhi-jie-cha-ru-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>假设待排序的记录存放在数组 $R[0…n-1]$中，排序过程的某一中间时刻，$R$ 被划分成两个子区间 $R_1[0…i-1]$ 和 $R_2[i…n-1]$ ，其中$R_1$ 为有序区（默认只有第一个元素），$R_2$ 为无序区。<br>直接插入排序的基本操作是将当前无序区的第1个记录 $R_2[i]$ 插入到有序区 $R_1[0…i-1]$ 中适当的位置上，使 $R_1[0…i]$ 变为新的有序区。<br>直接插入排序每次使有序区增加1个记录，故常称为增量法。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="zhe-ban-cha-ru-pai-xu">折半插入排序</span><a href="#zhe-ban-cha-ru-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>折半插入排序算法的步骤可分为三步：</p>
<ol>
<li>通过折半查找，找到 $R_2[i]$ 的位置；</li>
<li>移动有序区 $R_1[0…i-1]$ 中的元素，给 $R_2[i]$ 空出一个位置；</li>
<li>$R_2[i]$ 赋值到正确的位置</li>
</ol>
<p>因为 $R_2[i]$ 在有序区 $R_1[0…i-1]$ 中的位置是一定的，所以折半插入排序的元素移动次数与直接插入排序相同，不同的是找到该位置的计算量不同。</p>
<p>因为折半插入排序使用了折半查找，计算次数上肯定会少于使用顺序查找的直接插入排序，所以性能上有一定的优势。</p>
<blockquote>
<p>折半插入排序是直接插入排序的改进版。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> left,mid,right;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.key &lt; R[mid].key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=right+<span class="number">1</span>;j--)</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">        </span><br><span class="line">        R[right+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：不稳定</p>
<h3><span id="xi-er-pai-xu">希尔排序</span><a href="#xi-er-pai-xu" class="header-anchor">#</a></h3><p><strong>介绍</strong></p>
<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<blockquote>
<p>希尔排序按其设计者 Donald Shell 的名字命名，该算法由1959年公布。</p>
</blockquote>
<p><strong>基本思想</strong></p>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步。<br>然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p>
<blockquote>
<p>Donald Shell最初建议步长选择为 $\frac{n}{2}$，并且每一次循环对步长取半，直到步长达到 $1$。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    gap = n/<span class="number">2</span>;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap] = R[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^{1.3})$</p>
<p>稳定性：不稳定</p>
<h3><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;直接插入排序 ... \n&quot;</span>);</span><br><span class="line">    InsertSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;折半插入排序 ... \n&quot;</span>);</span><br><span class="line">    BinInsertSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shell插入排序 ... \n&quot;</span>);</span><br><span class="line">    ShellSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> left,mid,right;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.key &lt; R[mid].key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=right+<span class="number">1</span>;j--)</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">        </span><br><span class="line">        R[right+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shell插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    gap = n/<span class="number">2</span>;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap] = R[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/27/sort/">排序算法简介</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-27T05:00:00.000Z" itemprop="datePublished">Jul 27, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>整理“表”中的记录，使之按关键字递增（或递减）有序排列。</p>
<p>例如输入：</p>
<p>$n$ 个记录 $[R_0,R_1,R_2,…R_{n-1}]$，</p>
<p>关键字为 $[K_1,K_2,K_3,…K_{n-1}]$</p>
<p>经过排序…</p>
<p>输出：</p>
<p>$[R_{i0},R_{i1},R_{i2},…R_{in-1}]$，</p>
<p>使得 $[k_{i0}&lt;&#x3D;k_{i1}&lt;&#x3D;k_{i2}&lt;&#x3D;…&lt;&#x3D;k_{in-1}]$</p>
<p>（或者 $[k_{i0}&gt;&#x3D;k_{i1}&gt;&#x3D;k_{i2}&gt;&#x3D;…&gt;&#x3D;k_{in-1}]$）</p>
<h3><span id="pai-xu-suan-fa-de-xing-neng-ping-jie">排序算法的性能评价</span><a href="#pai-xu-suan-fa-de-xing-neng-ping-jie" class="header-anchor">#</a></h3><p>分别通过 <a href="/2020/06/01/time-complexity-algorithm#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6">算法复杂度</a> 和 算法稳定性 来评价排序算法的性能优劣。</p>
<p><strong>算法稳定性</strong></p>
<p>当待排序记录的关键字均不相同时，排序的结果是惟一的，也是稳定的。</p>
<p>如果待排序的表中，存在有多个关键字相同的记录：假如经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是稳定的；<br>反之，若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。</p>
<h3><span id="pai-xu-suan-fa-fen-lei">排序算法分类</span><a href="#pai-xu-suan-fa-fen-lei" class="header-anchor">#</a></h3><ol>
<li><a href="/2020/07/28/insert-sort">插入排序</a><ul>
<li>直接插入</li>
<li>希尔排序</li>
</ul>
</li>
<li><a href="/2020/07/30/select-sort">选择排序</a><ul>
<li>直接选择</li>
<li>堆排序</li>
</ul>
</li>
<li><a href="/2020/07/29/swap-sort">交换排序</a><ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li><a href="/2020/08/01/merge-sort">归并排序</a></li>
<li><a href="/2020/08/02/radix-sort">基数排序</a></li>
</ol>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/21/BST/">二叉查找树(BST)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-21T05:00:00.000Z" itemprop="datePublished">Jul 21, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/查找/">查找</a>
</div>
    </div>
      
        <h3><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor">#</a></h3><p>一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点；</li>
</ol>
<blockquote>
<p>二叉查找树又称为二叉搜索树，简称 <strong>BST</strong></p>
</blockquote>
<div style="display: flex;">
    <div float="left">
    <img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gh1x081xtmj20ab06zt8s.jpg" alt="二叉查找树" align="bottom">
    <center>图1 二叉查找树</center>
    </div>
    <div float="right">
    <img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gh1x0faozej20ab06zmxa.jpg" alt="非二叉查找树" align="bottom">
    <center>图2 非二叉查找树</center>
    </div>
</div>

<p>根据 <strong>BST</strong> 的性质，中序遍历图1，可得到一个有序的序列 <code>1 2 3 4 5 6 7</code>。</p>
<h3><span id="chuang-jian-bst">创建BST</span><a href="#chuang-jian-bst" class="header-anchor">#</a></h3><p>通过关键字序列来创建 <strong>BST</strong> 。</p>
<p>当二叉树为空时，把第一个节点当作根节点。<br>当二叉树不为空时，插入的值与根节点的值比较：</p>
<ol>
<li>若等于根节点的值，则丢弃该插入值；</li>
<li>若大于根节点的值，则插入以右子节点为根节点的二叉树中；</li>
<li>若小于根节点的值，则插入以左子节点为根节点的二叉树中；</li>
</ol>
<p>直到（左 或 右）子节点为空时，把插入值当作（左 或 右）子节点插入到二叉树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由有n个元素的数组A，创建一个二叉排序树</span></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt=<span class="literal">NULL</span>;                  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">            bt = GenerateNode(A[i]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            InsertBST(bt,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *tmp=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    tmp-&gt;key=k;</span><br><span class="line">    tmp-&gt;lchild=tmp-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p所指向的二叉排序树中，插入值为k的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)                 <span class="comment">//树中存在相同关键字的结点,返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)            <span class="comment">//插入到p的左子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">//插入到p的右子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;rchild,k); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="cha-zhao-jie-dian">查找节点</span><a href="#cha-zhao-jie-dian" class="header-anchor">#</a></h3><p>查找节点是创建 <strong>BST</strong> 的目的，查找的过程与创建的过程类似。</p>
<p>从根节点开始比较节点的关键字与目标值 $k$ （例如 $k&#x3D;5$ ）的大小，若比较结果相等则查找完成；<br>若不相等，再根据 $k$ 与该根节点关键字的比较大小确定下一步查找哪个子树。<br>递归进行下去，直到找到满足条件的节点或者该二叉树中没有这样的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在bt指向的节点为根的排序二叉树中，查找值为k的节点。找不到返回NULL</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span> || bt-&gt;key==k)         <span class="comment">//递归终结条件</span></span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="shan-chu-jie-dian">删除节点</span><a href="#shan-chu-jie-dian" class="header-anchor">#</a></h3><blockquote>
<p>删除节点的前提是二叉树有这个节点，所以在执行删除节点方法前，需用查找节点方法判定一下。</p>
</blockquote>
<p>通过关键值对比，找到了目标节点。</p>
<ol>
<li>若目标节点没有右子节点，则可能含有左子节点，则把目标节点的左子节点赋值给它自己；</li>
<li>若目标节点没有左子节点，则可能含有右子节点，则把目标节点的右子节点赋值给它自己；</li>
<li>若目标节点是双分支节点，则先找到左子节点 <strong>tmpchild</strong> ，此时分两种情况：<ul>
<li>若 <strong>tmpchild</strong> 没有右子节点，则 <strong>tmpchild</strong> 的值域为左子树中的最大值，把 <strong>tmpchild</strong> 的值域赋值给目标节点，然后释放 <strong>tmpchild</strong> 节点内存即可；</li>
<li>若 <strong>tmpchild</strong> 有右子节点，则找到 <strong>tmpchild</strong> 最大深度的右子节点，该节点的值域为左子树中的最大值，赋值给目标节点，释放内存即可。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除二叉搜索树中的一个节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>  <span class="comment">//在bt中删除关键字为k的结点</span></span><br><span class="line">&#123;   </span><br><span class="line">    BSTNode *tmpchild,*p;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt-&gt;key != k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = bt;                             <span class="comment">//  记录目标节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; bt-&gt;key)                     <span class="comment">//  往左找</span></span><br><span class="line">                bt = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; bt-&gt;key)               <span class="comment">//  往右找</span></span><br><span class="line">                bt = bt-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rchild == <span class="literal">NULL</span>)                  <span class="comment">//  目标节点无右孩子节点，则目标节点可能有左节点（左节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span>)             <span class="comment">//  目标节点无左孩子节点，则目标节点可能有右节点（右节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">//  目标节点有左右孩子节点，找到左子树的最大的右孩子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpchild = bt-&gt;lchild;              <span class="comment">//  左子树节点</span></span><br><span class="line">            <span class="keyword">if</span>(tmpchild-&gt;rchild == <span class="literal">NULL</span>)        <span class="comment">//  当左子树没有右孩子节点，则左子树节点就是 用来替换目标节点的 最大节点，</span></span><br><span class="line">            &#123;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;</span><br><span class="line">                bt-&gt;lchild = tmpchild-&gt;lchild;   <span class="comment">//  删除左子树节点，此时左子树节点没有右孩子节点，可能有左孩子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//  左子树节点有右孩子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (tmpchild-&gt;rchild != <span class="literal">NULL</span>)    <span class="comment">//  找到最大深度的右孩子节点，就是值最大的节点，并且记录它的父节点</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    p = tmpchild;</span><br><span class="line">                    tmpchild = tmpchild-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;            <span class="comment">//  替换目标节点的值</span></span><br><span class="line">                p-&gt;rchild = tmpchild-&gt;lchild;       <span class="comment">//  此时的 tmpchild 一定没有右子节点，但可能有左子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="xing-neng-ping-jie">性能评价</span><a href="#xing-neng-ping-jie" class="header-anchor">#</a></h3><p>当二叉搜索树上的节点均匀分布的时候（例如图1），二叉搜索树处于一个<strong>平衡的</strong>状态，此时的查找效率最高，时间复杂度为 $O(log_2n)$ 。<br>但是一般情况遇到的更多像图3这样的，甚至有像图4这样的最坏情况，时间复杂度达到 $O(n)$ ，像顺序查找一样。<br>所以 <strong>BST</strong> 的时间复杂度为[ $O(log_2n)$ , $O(n)$ ]。</p>
<div style="display: flex;">
    <div float="left">
    <img src="http://tva2.sinaimg.cn/large/7d4c6366gy1gh26jrf9qrj20bn09ndfz.jpg" alt="一般情况二叉查找树" align="bottom">
    <center>图3 一般情况二叉查找树</center>
    </div>
    <div float="right">
    <img src="http://tva1.sinaimg.cn/large/7d4c6366gy1gh25llq1swj20bn0hn3yw.jpg" alt="最坏情况二叉查找树" align="bottom">
    <center>图4 最坏情况二叉查找树</center>
    </div>
</div>

<h3><span id="wan-zheng-c-dai-ma">完整C代码</span><a href="#wan-zheng-c-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>                 //记录类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;                    <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;                  <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBST</span><span class="params">(BSTNode *bt)</span>;</span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span>;</span><br><span class="line">BSTNode *<span class="title function_">SearchBST_unr</span><span class="params">(BSTNode *bt,KeyType k)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>;</span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  二叉查找树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt;</span><br><span class="line">    <span class="type">int</span> del_num;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">12</span>,x=<span class="number">46</span>;</span><br><span class="line">    KeyType a[]= &#123;<span class="number">25</span>,<span class="number">18</span>,<span class="number">46</span>,<span class="number">2</span>,<span class="number">53</span>,<span class="number">39</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">60</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    bt=CreateBST(a,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BST:&quot;</span>);</span><br><span class="line">    DispBST(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除%d结点\n&quot;</span>,x);</span><br><span class="line">    <span class="keyword">if</span> (SearchBST(bt,x) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   <span class="comment">//  结果 ！= NULL 表示找到值域为x的节点</span></span><br><span class="line">        del_num = DeleteBST(bt,x);</span><br><span class="line">        <span class="keyword">if</span>(del_num)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成功删除结点 %d\n&quot;</span>,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BST:&quot;</span>);</span><br><span class="line">        DispBST(bt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由有n个元素的数组A，创建一个二叉排序树</span></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt=<span class="literal">NULL</span>;                  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">            bt = GenerateNode(A[i]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            InsertBST(bt,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *tmp=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    tmp-&gt;key=k;</span><br><span class="line">    tmp-&gt;lchild=tmp-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p所指向的二叉排序树中，插入值为k的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)                 <span class="comment">//树中存在相同关键字的结点,返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)            <span class="comment">//插入到p的左子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">//插入到p的右子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;rchild,k); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//括号表示法输出一棵排序二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBST</span><span class="params">(BSTNode *bt)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,bt-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild != <span class="literal">NULL</span> || bt-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);                        <span class="comment">//有孩子结点时才输出(</span></span><br><span class="line">            DispBST(bt-&gt;lchild);                <span class="comment">//递归处理左子树</span></span><br><span class="line">            <span class="keyword">if</span> (bt-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);  <span class="comment">//有右孩子结点时才输出,</span></span><br><span class="line">            DispBST(bt-&gt;rchild);                <span class="comment">//递归处理右子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);                        <span class="comment">//有孩子结点时才输出)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在bt指向的节点为根的排序二叉树中，查找值为k的节点。找不到返回NULL</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span> || bt-&gt;key==k)         <span class="comment">//递归终结条件</span></span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树中查找的非递归算法</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST_unr</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k==bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> bt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line">            bt=bt-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bt=bt-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除二叉搜索树中的一个节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>  <span class="comment">//在bt中删除关键字为k的结点</span></span><br><span class="line">&#123;   </span><br><span class="line">    BSTNode *tmpchild,*p;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt-&gt;key != k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = bt;                             <span class="comment">//  记录目标节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; bt-&gt;key)                     <span class="comment">//  往左找</span></span><br><span class="line">                bt = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; bt-&gt;key)               <span class="comment">//  往右找</span></span><br><span class="line">                bt = bt-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rchild == <span class="literal">NULL</span>)                  <span class="comment">//  目标节点无右孩子节点，则目标节点可能有左节点（左节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span>)             <span class="comment">//  目标节点无左孩子节点，则目标节点可能有右节点（右节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">//  目标节点有左右孩子节点，找到左子树的最大的右孩子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpchild = bt-&gt;lchild;              <span class="comment">//  左子树节点</span></span><br><span class="line">            <span class="keyword">if</span>(tmpchild-&gt;rchild == <span class="literal">NULL</span>)        <span class="comment">//  当左子树没有右孩子节点，则左子树节点就是 用来替换目标节点的 最大节点，</span></span><br><span class="line">            &#123;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;</span><br><span class="line">                bt-&gt;lchild = tmpchild-&gt;lchild;   <span class="comment">//  删除左子树节点，此时左子树节点没有右孩子节点，可能有左孩子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//  左子树节点有右孩子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (tmpchild-&gt;rchild != <span class="literal">NULL</span>)    <span class="comment">//  找到最大深度的右孩子节点，就是值最大的节点，并且记录它的父节点</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    p = tmpchild;</span><br><span class="line">                    tmpchild = tmpchild-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;            <span class="comment">//  替换目标节点的值</span></span><br><span class="line">                p-&gt;rchild = tmpchild-&gt;lchild;       <span class="comment">//  此时的 tmpchild 一定没有右子节点，但可能有左子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/19/leetcode-04.02/">leetcode 面试题 04.02e. 最小高度树</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-19T02:00:00.000Z" itemprop="datePublished">Jul 19, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/leetcode/">leetcode</a>
</div>
    </div>
      
        <h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">          0 </span><br><span class="line">         / \ </span><br><span class="line">       -3   9 </span><br><span class="line">       /   / </span><br><span class="line">     -10  5 </span><br></pre></td></tr></table></figure>


<h3><span id="suan-fa">算法</span><a href="#suan-fa" class="header-anchor">#</a></h3><p>已知有一个升序 有序的 整数数组，要构造一棵高度最小的二叉搜索树。</p>
<p>根据二叉搜索树的定义可知：分支节点上的值大于左子树上节点的值，小于右子树上节点的值，且二叉搜索树上的没有健值相等的节点。</p>
<p>高度最小则需要符合完全二叉树的特点。</p>
<p>因此可以使用 递归+二分法 从整数数组里逐个取出节点，构成一个二叉树。</p>
<h3><span id="di-gui-er-fen-fa">递归+二分法</span><a href="#di-gui-er-fen-fa" class="header-anchor">#</a></h3><p>递归+二分法 的重点在于边界值的确定。</p>
<ol>
<li>[0,numsSize-1]</li>
</ol>
<p>左右边界值分别是数组开始索引的和结束索引，每次取出中间值后，数组分成了三部分：[0,mid-1],mid,[mid+1,numsSize-1]。再分别对左右两个数组递归调用。结束递归的条件是数组的左边索引值 $l$ <strong>大于</strong> 右边索引值 $r$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray_2</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray_2(nums, l, mid<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = recursionsortedarray_2(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>[0,numsSize]</li>
</ol>
<p>左右边界值分别是数组开始索引的和数组数量，每次取出中间值后，数组分成了三部分：[0,mid],mid,[mid+1,numsSize]。再分别对左右两个数组递归调用。结束递归的条件是数组的左边索引值 $l$ <strong>大于等于</strong> 右边索引值 $r$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray(nums, l, mid);</span><br><span class="line">    root-&gt;right = recursionsortedarray(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法都可以得到一个高度 $h$ 一样的二叉树，但是第一种的到的结果不符合完成二叉树，所以应该采用第二种边界值方法。</p>
<img src="http://tva4.sinaimg.cn/large/7d4c6366gy1ggwexsuchfj21jb267n5m.jpg" width="700" align="bottom">

<h3><span id="c-dai-ma">C代码</span><a href="#c-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> TreeNode *<span class="title function_">creatnewnode</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;val = num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray(nums, l, mid);</span><br><span class="line">    root-&gt;right = recursionsortedarray(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> recursionsortedarray(nums, <span class="number">0</span>, numsSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left != <span class="literal">NULL</span> || T-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                disTree(T-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                disTree(T-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numsSize = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">T</span> =</span> sortedArrayToBST(nums,numsSize);</span><br><span class="line">    disTree(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/18/linear-search/">顺序查找和折半查找</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-18T20:00:00.000Z" itemprop="datePublished">Jul 19, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/查找/">查找</a>
</div>
    </div>
      
        <h3><span id="shun-xu-biao-cha-zhao">顺序表查找</span><a href="#shun-xu-biao-cha-zhao" class="header-anchor">#</a></h3><p><strong>查找思路</strong></p>
<p>例如 $[1,3,5,7,9,4,6,8,2]$ 为查找表的关键字数组，目标是找到关键字 $k&#x3D;9$ 的记录。</p>
<p>从表的一端开始，顺序扫描线性表，依次将扫描到的关键字和给定值 $k$ 相比较，若当前扫描到的关键字与 $k$ 相等，则查找成功；若扫描结束后，仍未找到关键字等于 $k$ 的记录，则查找失败。</p>
<p><strong>性能评价</strong></p>
<p><a href="/2020/07/17/search-introduction#%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6aslaverage-search-length">平均查找长度</a> 公式：<br>$ASL &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}$</p>
<p>$p_i &#x3D; \frac{1}{n}$ </p>
<p>$c_i$ 为关键字在数组中的位置序号， $c_i$ 的累加和为: $1+2+3+…+n &#x3D; \frac{n*(n+1)}{2}$</p>
<p>所以：$ASL &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}&#x3D;\frac{n+1}{2}$</p>
<p>所以顺序查找的时间复杂度为： $O(n)$ 。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXL 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data; </span><br><span class="line">&#125; NodeType;</span><br><span class="line"><span class="keyword">typedef</span> NodeType SeqList[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span><span class="params">(SeqList R,<span class="type">int</span> n,KeyType k)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    SeqList R;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,x=<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    result = SeqSearch(R,<span class="number">10</span>,x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;序列中第%d个是%d\n&quot;</span>,result,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="comment">//逐个匹配，找到返回逻辑下标，未找到返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span><span class="params">(SeqList R,<span class="type">int</span> n,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; R[i].key != k)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="zhe-ban-cha-zhao">折半查找</span><a href="#zhe-ban-cha-zhao" class="header-anchor">#</a></h3><p><strong>前提条件</strong></p>
<p>线性表中的节点，按关键字值的递增或递减顺序排列。例如： $[2,3,10,15,20,25,28,29,30,35,40]$ 。</p>
<p><strong>查找思路</strong></p>
<p>首先用要查找的关键字 $k$（例如 $k&#x3D;20$ ）与中间位置的节点的关键字比较，若比较结果相等则查找完成；若不相等，再根据 $k$ 与该中间节点关键字的比较大小确定下一步查找哪个子表。递归进行下去，直到找到满足条件的节点或者该线性表中没有这样的节点。</p>
<p><strong>性能评价</strong></p>
<img src="http://tvax2.sinaimg.cn/large/7d4c6366gy1ggyeoffzxtj20nb0cbmxt.jpg" width="700" align="bottom">
<center>图1</center>

<p>将折半查找过程用二叉树来描述(如图1)，把当前查找区间的中间位置上的记录作为根；左子表和右子表中的记录分别作为根的左、右子树。</p>
<p>成功的折半查找过程，恰好是走了一条从根到被查记录的路径，比较次数恰为该记录在树中的层数 $h$ 。</p>
<p>$ASL_{succ} &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}&#x3D;\frac{1+2 * 2+3 * 4+4 * 4}{11}&#x3D;3$ </p>
<p>若查找失败，则其比较过程是一条从根到某个外部节点的路径，所需的比较次数是该路径上内部节点的总数 $h-1$ 。</p>
<p>$ASL_{unsucc} &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}&#x3D;\frac {3 * 4+4 * 8}{11}&#x3D;3.67$</p>
<img src="http://tva3.sinaimg.cn/large/7d4c6366gy1ggyloldyloj20kz09nmxk.jpg" width="700" align="bottom">
<center>图2</center>

<p>假设折半查找的数组有 $n$ 个有序的，互不相同的元素 $(n&#x3D;2^h-1,h&gt;&#x3D;0)$ ，则该折半查找过程可用满二叉树来描述(如图2)，根据满二叉树的性质有：</p>
<ul>
<li>节点总数 $n&#x3D;2^h-1$</li>
<li>树的高度 $h&#x3D;log_2(n+1)$</li>
<li>第 $i$ 层上的记录个数 $2^{i-1}$</li>
</ul>
<p>$ASL_{bn} &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}$</p>
<p>因为第 $i$ 层上的 <strong>某个节点</strong> 的平均查找长度为 $\frac {1}{n} * i$ </p>
<p>所以第 $i$ 层上的 <strong>所有节点</strong> 的平均查找长度为 $\frac {1}{n} * i * 2^{i-1}$</p>
<p>所以满二叉树的平均查找长度为每一层平均查找长度的累加为 $\frac{1}{n} \displaystyle  \sum^{h}_{i&#x3D;1}{2^{i-1}*i}$</p>
<p>因为 $\displaystyle  \sum^{h}_{i&#x3D;1}{2^{i-1} * i} &#x3D;1+(h-1) * 2^h$</p>
<p>所以 $ASL_{bn}&#x3D;\frac{1}{n} * [1+(h-1) * 2^h]$</p>
<p>$&#x3D;\frac{1}{n} * [1+(log_2(n+1)-1) * (n+1)]$</p>
<p>约等于 $log_2(n+1)-1$</p>
<p>所以满二叉树的折半查找的时间复杂度为 $O(log_2n)$</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXL 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data; </span><br><span class="line">&#125; NodeType;</span><br><span class="line"><span class="keyword">typedef</span> NodeType SeqList[MAXL];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch_r</span><span class="params">(SeqList R,<span class="type">int</span> low,<span class="type">int</span> high,KeyType k)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,n=<span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    SeqList R;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>&#125;,x=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    result = BinSearch_r(R,<span class="number">0</span>,n<span class="number">-1</span>,x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;序列中第%d个是%d\n&quot;</span>,result,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//折半查找，递归方式</span></span><br><span class="line"><span class="comment">//前提条件是待查找的序列是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch_r</span><span class="params">(SeqList R,<span class="type">int</span> low,<span class="type">int</span> high,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (R[mid].key == k)</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(R[mid].key &gt; k)</span><br><span class="line">            <span class="keyword">return</span> BinSearch_r(R,low,mid<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BinSearch_r(R,mid+<span class="number">1</span>,high,k);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/17/search-introduction/">查找简介</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-17T05:00:00.000Z" itemprop="datePublished">Jul 17, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/查找/">查找</a>
</div>
    </div>
      
        <h3><span id="cha-zhao-de-ding-yi">查找的定义</span><a href="#cha-zhao-de-ding-yi" class="header-anchor">#</a></h3><p>给定一个值 $k$ ，在含有 $n$ 个记录的表中找出关键字等于 $k$ 的记录。若找到，则查找成功，返回该记录的信息或该记录在表中的位置；否则查找失败，返回相关的指示信息 。</p>
<h3><span id="cha-zhao-de-dui-xiang">查找的对象</span><a href="#cha-zhao-de-dui-xiang" class="header-anchor">#</a></h3><p>一组记录组成的表或文件，每个记录则由若干个数据项组成，其中必须含有一个能唯一标识该记录的数据项——叫做关键字。</p>
<h3><span id="cha-zhao-de-fang-fa">查找的方法</span><a href="#cha-zhao-de-fang-fa" class="header-anchor">#</a></h3><p>基于不同的数据结构和存储结构，有不同的查找方法。有：顺序表、链表、树表、哈希表等。</p>
<h3><span id="cha-zhao-de-liang-chong-ji-ben-xing-shi">查找的两种基本形式</span><a href="#cha-zhao-de-liang-chong-ji-ben-xing-shi" class="header-anchor">#</a></h3><p>静态查找(Static Search)：在查找的时候只对数据元素进行查询或检索，查找表称为静态查找表。</p>
<p>动态查找(Dynamic Search)：在实施查找的同时，插入查找表中不存在的记录，或从查找表中删除已存在的某个记录，查找表称为动态查找表。</p>
<h3><span id="ping-jun-cha-zhao-chang-du-asl-average-search-length">平均查找长度ASL（Average Search Length）</span><a href="#ping-jun-cha-zhao-chang-du-asl-average-search-length" class="header-anchor">#</a></h3><p>查找的主要运算是关键字的比较，常把查找过程中对关键字需要执行的平均比较次数，作为衡量一个查找算法效率优劣的标准，平均比较次数，也称为平均查找长度。</p>
<p>$ASL &#x3D; \displaystyle \sum^{n}_{i&#x3D;1}{p_i * c_i}$</p>
<p>分别有：查找成功是的 $ASL_{succ}$ 和查找不成功时的 $ASL_{unsucc}$ 。</p>
<ul>
<li>$n$ 是查找表中记录的个数</li>
<li>$p_i$ 表示查找第 $i$ 个记录的概率，一般认为每个记录的查找概率相等，即是 $p_i&#x3D; \frac{1}{n}$ </li>
<li>$c_i$ 是找到第 $i$ 个记录所需进行的比较次数。</li>
</ul>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/15/btree-traversal/">二叉树的遍历</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-15T05:00:00.000Z" itemprop="datePublished">Jul 15, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/树/">树</a>
</div>
    </div>
      
        <h3><span id="xian-xu-bian-li-di-gui-ban">先序遍历（递归版）</span><a href="#xian-xu-bian-li-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  先序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">        PreOrderRcs(b-&gt;lchild);</span><br><span class="line">        PreOrderRcs(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="zhong-xu-bian-li-di-gui-ban">中序遍历（递归版）</span><a href="#zhong-xu-bian-li-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderRcs(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">        InOrderRcs(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="hou-xu-bian-li-di-gui-ban">后序遍历（递归版）</span><a href="#hou-xu-bian-li-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderRcs(b-&gt;lchild);</span><br><span class="line">        PostOrderRcs(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="xian-xu-bian-li-fei-di-gui-ban">先序遍历（非递归版）</span><a href="#xian-xu-bian-li-fei-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  前序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        st[top] = b;</span><br><span class="line">        <span class="comment">//先把跟节点放入栈中</span></span><br><span class="line">        <span class="comment">//循环从栈中取出元素</span></span><br><span class="line">        <span class="comment">//并访问元素的值（输出结果）</span></span><br><span class="line">        <span class="comment">//然后先放右子树，再放左子树</span></span><br><span class="line">        <span class="comment">//根据栈的特点，先取左子树，后取右子树</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            tmp = st[top--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;rchild != <span class="literal">NULL</span>) st[++top] = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;lchild != <span class="literal">NULL</span>) st[++top] = tmp-&gt;lchild;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="zhong-xu-bian-li-fei-di-gui-ban">中序遍历（非递归版）</span><a href="#zhong-xu-bian-li-fei-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        tmp = b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span> || tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  不断把左子树节点入栈，直到遇到叶子节点</span></span><br><span class="line">            <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                st[top] = tmp;</span><br><span class="line">                tmp = tmp-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始出栈，并且返回右子树阶段</span></span><br><span class="line">            <span class="comment">//重新开始查找左子树</span></span><br><span class="line">            <span class="keyword">if</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = st[top];</span><br><span class="line">                top--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">                tmp = tmp-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="hou-xu-bian-li-fei-di-gui-ban">后序遍历（非递归版）</span><a href="#hou-xu-bian-li-fei-di-gui-ban" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;   <span class="comment">//  tmp指针用于存储有孩子节点，默认为NULL</span></span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>,flag;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                st[top] = b;</span><br><span class="line">                b = b-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="literal">NULL</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; flag)</span><br><span class="line">            &#123;</span><br><span class="line">                b = st[top];</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;rchild == tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">                    top--;</span><br><span class="line">                    tmp = b;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    b = b-&gt;rchild;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (top != <span class="number">-1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="ceng-ci-bian-li">层次遍历</span><a href="#ceng-ci-bian-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用循环队列实现二叉树的层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *qu[MaxSize],*tmp;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        tmp = qu[front];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = tmp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = tmp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;        <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span>  <span class="comment">//指向左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span>  <span class="comment">//指向右孩子</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *<span class="title function_">CreateBTNode</span><span class="params">(<span class="type">char</span> *str)</span>;  <span class="comment">//由str串创建二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode *b)</span>;       <span class="comment">//以括号表示法输出二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderRcs</span><span class="params">(BTNode *b)</span>;      <span class="comment">//先序遍历的 递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderRcs</span><span class="params">(BTNode *b)</span>;       <span class="comment">//中序遍历的 递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderRcs</span><span class="params">(BTNode *b)</span>;     <span class="comment">//后序遍历的 递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderNRcs</span><span class="params">(BTNode *b)</span>;     <span class="comment">//先序遍历的 非递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderNRcs</span><span class="params">(BTNode *b)</span>;      <span class="comment">//中序遍历的 非递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderNRcs</span><span class="params">(BTNode *b)</span>;    <span class="comment">//后序遍历的 非递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span>;       <span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode *b)</span>;    <span class="comment">//销毁二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  二叉树的遍历（先序遍历，中序遍历，后序遍历，层次遍历）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *b;</span><br><span class="line">    <span class="type">char</span> cstr[] = <span class="string">&quot;A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (1)创建二叉树:&quot;</span>);</span><br><span class="line">    b = CreateBTNode(cstr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (2)输出二叉树:&quot;</span>);</span><br><span class="line">    DispBTNode(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (3)先序遍历（递归）序列:&quot;</span>);</span><br><span class="line">    PreOrderRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (4)中序遍历（递归）序列:&quot;</span>);</span><br><span class="line">    InOrderRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (5)后序遍历（递归）序列:&quot;</span>);</span><br><span class="line">    PostOrderRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (6)先序遍历（非递归）序列:&quot;</span>);</span><br><span class="line">    PreOrderNRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (7)中序遍历（非递归）序列:&quot;</span>);</span><br><span class="line">    InOrderNRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (8)后序遍历（非递归）序列:&quot;</span>);</span><br><span class="line">    PostOrderNRcs(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (9)层次遍历序列:&quot;</span>);</span><br><span class="line">    LevelOrder(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (10)释放二叉树b\n&quot;</span>);</span><br><span class="line">    DestroyBTNode(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode *<span class="title function_">CreateBTNode</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *tmp=<span class="literal">NULL</span>,*T=<span class="literal">NULL</span>,*tmpStack[MaxSize];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>,i = <span class="number">0</span>,k;</span><br><span class="line">    <span class="type">char</span> ch ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ch = str[i++]) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            tmpStack[++top] = tmp;  <span class="comment">//  左括号前面的节点入栈</span></span><br><span class="line">            k = <span class="number">1</span>;  <span class="comment">//  左括号后面跟着左子树 用 k=1 表示</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            top--;  <span class="comment">//  出栈</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">            k = <span class="number">2</span>;  <span class="comment">// 右括号后面跟着右子树 用 k=2 表示</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            tmp = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">            tmp-&gt;data = ch;</span><br><span class="line">            tmp-&gt;lchild = tmp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">                T = tmp;    <span class="comment">//  第一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">switch</span> (k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        tmpStack[top]-&gt;lchild = tmp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        tmpStack[top]-&gt;rchild = tmp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data); </span><br><span class="line">       <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;    <span class="comment">//  有左子树 或者 右子树 时，输出括号</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); </span><br><span class="line">            <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                DispBTNode(b-&gt;lchild);  <span class="comment">// 有左子树时 输出左子树</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;rchild != <span class="literal">NULL</span>)   <span class="comment">//  右子树时，输出逗号和右子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>); </span><br><span class="line">                DispBTNode(b-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  前序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">        PreOrderRcs(b-&gt;lchild);</span><br><span class="line">        PreOrderRcs(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderRcs(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">        InOrderRcs(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderRcs(b-&gt;lchild);</span><br><span class="line">        PostOrderRcs(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  前序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        st[top] = b;</span><br><span class="line">        <span class="comment">//先把跟节点放入栈中</span></span><br><span class="line">        <span class="comment">//循环从栈中取出元素</span></span><br><span class="line">        <span class="comment">//并访问元素的值（输出结果）</span></span><br><span class="line">        <span class="comment">//然后先放右子树，再放左子树</span></span><br><span class="line">        <span class="comment">//根据栈的特点，先取左子树，后取右子树</span></span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            tmp = st[top--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;rchild != <span class="literal">NULL</span>) st[++top] = tmp-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;lchild != <span class="literal">NULL</span>) st[++top] = tmp-&gt;lchild;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        tmp = b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">-1</span> || tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  不断把左子树节点入栈，直到遇到叶子节点</span></span><br><span class="line">            <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                st[top] = tmp;</span><br><span class="line">                tmp = tmp-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始出栈，并且返回右子树阶段</span></span><br><span class="line">            <span class="comment">//重新开始查找左子树</span></span><br><span class="line">            <span class="keyword">if</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = st[top];</span><br><span class="line">                top--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">                tmp = tmp-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 non-recursion</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderNRcs</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BTNode *st[MaxSize],*tmp;   <span class="comment">//  tmp指针用于存储有孩子节点，默认为NULL</span></span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span>,flag;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                st[top] = b;</span><br><span class="line">                b = b-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="literal">NULL</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; flag)</span><br><span class="line">            &#123;</span><br><span class="line">                b = st[top];</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;rchild == tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data);</span><br><span class="line">                    top--;</span><br><span class="line">                    tmp = b;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    b = b-&gt;rchild;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (top != <span class="number">-1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用循环队列实现二叉树的层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *qu[MaxSize],*tmp;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    rear++;</span><br><span class="line">    qu[rear] = b;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        tmp = qu[front];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tmp-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = tmp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = (rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">            qu[rear] = tmp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyBTNode(b-&gt;lchild);</span><br><span class="line">        DestroyBTNode(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/13/btree-storage/">二叉树的存储</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-13T05:00:00.000Z" itemprop="datePublished">Jul 13, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/树/">树</a>
</div>
    </div>
      
        <h3><span id="er-cha-shu-de-chou-xiang-shu-ju-lei-xing">二叉树的抽象数据类型</span><a href="#er-cha-shu-de-chou-xiang-shu-ju-lei-xing" class="header-anchor">#</a></h3><p>二叉树是有相同特性的n(n&gt;&#x3D;0)个数据节点组成的一个有穷序列，节点之间存在一对多的关系。</p>
<p>严格区分左子树和右子树，并且先有左子树后有右子树。</p>
<p>树的抽象运算方法有：构造树，遍历树，查找节点，查找左右子树等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree</span><br><span class="line">&#123;</span><br><span class="line">数据对象：</span><br><span class="line">    D = &#123;ai | ai ∈ ElemType, i=<span class="number">1</span>,<span class="number">2</span>,…,n, n&gt;=<span class="number">0</span> &#125;              <span class="comment">// ElemType为类型标识符</span></span><br><span class="line">数据关系：</span><br><span class="line">    R = &#123;&lt;ai,aj&gt; | ai, aj∈D, i=<span class="number">1</span>,<span class="number">2</span>,…,n, j=<span class="number">1</span>,<span class="number">2</span>,…,n，其中每个元素只有一个前驱节点 ，可以有零个或多个后继节点，有且仅有一个元素（根节点）没有前驱节点 &#125;</span><br><span class="line">数据操作：</span><br><span class="line">    BTNode *CreateBTNode(<span class="type">char</span> *str);            <span class="comment">//由str串创建二叉树</span></span><br><span class="line">    BTNode *<span class="title function_">FindNode</span><span class="params">(BTNode *b, ElemType x)</span>;    <span class="comment">//返回data域为x的节点指针</span></span><br><span class="line">    BTNode *<span class="title function_">LchildNode</span><span class="params">(BTNode *p)</span>;              <span class="comment">//返回p节点的左孩子节点指针</span></span><br><span class="line">    BTNode *<span class="title function_">RchildNode</span><span class="params">(BTNode *p)</span>;              <span class="comment">//返回p节点的右孩子节点指针</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode *b)</span>;                 <span class="comment">//求二叉树b的深度</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode *b)</span>;                 <span class="comment">//以括号表示法输出二叉树</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode *b)</span>;              <span class="comment">//销毁二叉树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="shun-xu-cun-chu-jie-gou">顺序存储结构</span><a href="#shun-xu-cun-chu-jie-gou" class="header-anchor">#</a></h3><p>顺序存储结构把树节点保存到连续的存储空间中，借助于 <strong><a href="/2020/06/17/string#%E9%A1%BA%E5%BA%8F%E4%B8%B2">串结构</a></strong> 的运算构造二叉树。</p>
<p>根据 <strong><a href="/2020/07/11/btree#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">性质4</a></strong> 可知：</p>
<ul>
<li>若编号为 $i$ 的节点是分支节点，那么其左子节点编号为 $2i$ ，其右子节点编号为$2i+1$ ；</li>
<li>若编号为 $i$ 的节点不是根节点，那么其父节点编号为 $floor(i&#x2F;2)$ 。</li>
</ul>
<p>利用 <strong>性质4</strong> 可以很方便的找到父节点或者子节点。</p>
<p>顺序存储结构的优点是节省空间，缺点是描述二叉树作为参数输入比较麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助串结构构造顺序存储结构二叉树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="type">char</span> data[MaxSize];         </span><br><span class="line">    <span class="type">int</span> length;                 </span><br><span class="line">&#125; treeSeq;</span><br><span class="line"></span><br><span class="line">treeSeq * <span class="title function_">InitTree</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(treeSeq *t,<span class="type">char</span> *str)</span>; <span class="comment">//由str串创建二叉树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindNode</span><span class="params">(treeSeq *t,<span class="type">char</span> c)</span>;       <span class="comment">//返查找节点</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">LchildNode</span><span class="params">(treeSeq *t,<span class="type">int</span> index)</span>; <span class="comment">//返回指定编号节点的左孩子节点</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">RchildNode</span><span class="params">(treeSeq *t,<span class="type">int</span> index)</span>; <span class="comment">//返回指定编号节点的右孩子节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxIndex</span><span class="params">(treeSeq *t)</span>;              <span class="comment">//返回树节点的最大编号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(<span class="type">int</span> index)</span>;              <span class="comment">//根据节点的最大编号求二叉树的深度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispTree</span><span class="params">(treeSeq *t)</span>;             <span class="comment">//输出二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyTree</span><span class="params">(treeSeq *t)</span>;          <span class="comment">//销毁二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cstr[] = <span class="string">&quot;ABCDEFG##H####I&quot;</span>;</span><br><span class="line">    treeSeq *t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (1)初始化，创建二叉树:&quot;</span>);</span><br><span class="line">    t = InitTree();</span><br><span class="line">    CreateTree(t,cstr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (2)输出二叉树:&quot;</span>);</span><br><span class="line">    DispTree(t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (3)查找节点B:&quot;</span>);</span><br><span class="line">    <span class="type">int</span> index = FindNode(t, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(index) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;节点B的index=%d\n&quot;</span>,index);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  (4)&quot;</span>);</span><br><span class="line">        <span class="type">char</span> lp = LchildNode(t,index);</span><br><span class="line">        <span class="keyword">if</span> (lp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;左孩子为%c &quot;</span>, lp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无左孩子 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> rp = RchildNode(t,index);</span><br><span class="line">        <span class="keyword">if</span> (rp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;右孩子为%c&quot;</span>, rp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无右孩子 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;节点B未找到！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> maxIndex = MaxIndex(t);</span><br><span class="line">    <span class="type">int</span> h = TreeDepth(maxIndex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (4)二叉树b的深度:%d\n&quot;</span>, h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (5)释放二叉树t\n&quot;</span>);</span><br><span class="line">    DestroyTree(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空树</span></span><br><span class="line">treeSeq * <span class="title function_">InitTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    treeSeq *tmp = (treeSeq *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(treeSeq));</span><br><span class="line">    tmp-&gt;data[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    tmp-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串表示法创建二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(treeSeq *t,<span class="type">char</span> cstr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cstr[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t-&gt;data[i+<span class="number">1</span>] = cstr[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;length = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispTree</span><span class="params">(treeSeq *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;t-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindNode</span><span class="params">(treeSeq *t, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;t-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;data[i] == c) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左子树</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">LchildNode</span><span class="params">(treeSeq *t,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>*index &gt; t-&gt;length || t-&gt;data[<span class="number">2</span>*index] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t-&gt;data[<span class="number">2</span>*index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右子树</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">RchildNode</span><span class="params">(treeSeq *t,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>*index+<span class="number">1</span> &gt; t-&gt;length || t-&gt;data[<span class="number">2</span>*index] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t-&gt;data[<span class="number">2</span>*index+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h++;</span><br><span class="line">        index = (<span class="type">int</span>)<span class="built_in">floor</span>(index/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大节点编号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxIndex</span><span class="params">(treeSeq *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t-&gt;length;i&gt;<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;data[i] != <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyTree</span><span class="params">(treeSeq *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="lian-shi-cun-chu-jie-gou">链式存储结构</span><a href="#lian-shi-cun-chu-jie-gou" class="header-anchor">#</a></h3><p>一个树节点包括有一个值域和两个分别指向左子树和右子树的指针，链式存储结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;         <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span>   <span class="comment">//指向左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span>   <span class="comment">//指向右孩子</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;         <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span>   <span class="comment">//指向左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span>   <span class="comment">//指向右孩子</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"></span><br><span class="line">BTNode *<span class="title function_">CreateBTNode</span><span class="params">(<span class="type">char</span> *str)</span>;         <span class="comment">//由str串创建二叉树</span></span><br><span class="line">BTNode *<span class="title function_">FindNode</span><span class="params">(BTNode *b, ElemType x)</span>; <span class="comment">//返回data域为x的节点指针</span></span><br><span class="line">BTNode *<span class="title function_">LchildNode</span><span class="params">(BTNode *p)</span>;           <span class="comment">//返回p节点的左孩子节点指针</span></span><br><span class="line">BTNode *<span class="title function_">RchildNode</span><span class="params">(BTNode *p)</span>;           <span class="comment">//返回p节点的右孩子节点指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode *b)</span>;              <span class="comment">//求二叉树b的深度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode *b)</span>;              <span class="comment">//以括号表示法输出二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode *b)</span>;           <span class="comment">//销毁二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *b, *p, *lp, *rp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (1)创建二叉树:&quot;</span>);</span><br><span class="line">    b = CreateBTNode(<span class="string">&quot;A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (2)输出二叉树:&quot;</span>);</span><br><span class="line">    DispBTNode(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (3)查找H节点:&quot;</span>);</span><br><span class="line">    p = FindNode(b, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lp = LchildNode(p);</span><br><span class="line">        <span class="keyword">if</span> (lp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;左孩子为%c &quot;</span>, lp-&gt;data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无左孩子 &quot;</span>);</span><br><span class="line">        rp = RchildNode(p);</span><br><span class="line">        <span class="keyword">if</span> (rp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;右孩子为%c&quot;</span>, rp-&gt;data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无右孩子 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 未找到！&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (4)二叉树b的深度:%d\n&quot;</span>, BTNodeDepth(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  (5)释放二叉树b\n&quot;</span>);</span><br><span class="line">    DestroyBTNode(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTNode</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyBTNode(b-&gt;lchild);</span><br><span class="line">        DestroyBTNode(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lchilddep, rchilddep;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lchilddep = BTNodeDepth(b-&gt;lchild);</span><br><span class="line">        rchilddep = BTNodeDepth(b-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (lchilddep &gt; rchilddep) ? (lchilddep + <span class="number">1</span>) : (rchilddep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左子树</span></span><br><span class="line">BTNode *<span class="title function_">LchildNode</span><span class="params">(BTNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右子树</span></span><br><span class="line">BTNode *<span class="title function_">RchildNode</span><span class="params">(BTNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//括号表示法创建二叉树</span></span><br><span class="line">BTNode *<span class="title function_">CreateBTNode</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *st[MaxSize], *p = <span class="literal">NULL</span>,*b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>, k, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = str[j];</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            top++;</span><br><span class="line">            st[top] = p;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">            k = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">            p-&gt;data = ch;</span><br><span class="line">            p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//第一个元素为根节点，</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">                b = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (k)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    st[top]-&gt;lchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    st[top]-&gt;rchild = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ch = str[++j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//括号表示法输出二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBTNode</span><span class="params">(BTNode *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b-&gt;data); </span><br><span class="line">       <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span> || b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); </span><br><span class="line">            <span class="keyword">if</span>(b-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                DispBTNode(b-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>); </span><br><span class="line">                DispBTNode(b-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找节点</span></span><br><span class="line">BTNode *<span class="title function_">FindNode</span><span class="params">(BTNode *b, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    BTNode *p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FindNode(b-&gt;lchild, x);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
	</div>

<div class="meta">
	
</div>
</article>


  <nav id="pagenavi">
    
        <a href="/page/2/" class="prev">Prev</a>
    
    
        <a href="/page/4/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2022

    CFONG
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
