<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>不知有晋</title>
    <meta name="author" content="CFONG">
    
	<meta name="description" content=""> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="不知有晋" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='//fonts.googleapis.com/css?family=Slackey' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Amethysta' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>
    <script src="/javascripts/MathJax.js" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        不知有晋
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  
  
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">Home</a></li>
	<li id="ajax"><a href="/archives/index.html">Archives</a></li>
	<li id="ajax"><a href="/tags/index.html">Tags</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="http://fonghub.github.com" />
            <input type="text" name="q" results="0" placeholder="Search..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        



  <article class="post">
	<h2 class="title">
		<a href="2020/08/22/PHP-extensions/">Windows下PHP如何添加扩展</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-08-22T19:00:00.000Z" itemprop="datePublished">Aug 23, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/php/">php</a>
</div>
    </div>
      
        <p>Windows下，PHP添加扩展，步骤如下：</p>
<ol>
<li>找到目标扩展</li>
<li>把扩展文件放到PHP扩展文件夹里</li>
<li>添加扩展配置</li>
<li>重启</li>
</ol>
<p>下面以添加redis扩展为例。</p>
<h3><span id="que-ding-php-ban-ben-xin-xi">确定PHP版本信息</span><a href="#que-ding-php-ban-ben-xin-xi" class="header-anchor">#</a></h3><p>访问 <strong>phpinfo.php</strong>，找到这三个字段的值：</p>
<ul>
<li>PHP Version</li>
<li>Architecture</li>
<li>Thread Safety</li>
</ul>
<img src="http://tva4.sinaimg.cn/large/7d4c6366gy1gi1x35ukyvj20q60mo0u1.jpg" width="700" align="bottom">
<center>phpinfo</center>

<p>从上图可知，需要找支持PHP版本7.0、x86架构、线程安全的redis扩展。</p>
<h3><span id="cha-zhao-kuo-zhan">查找扩展</span><a href="#cha-zhao-kuo-zhan" class="header-anchor">#</a></h3><p>到<a target="_blank" rel="noopener" href="http://pecl.php.net/">PECL</a>查找redis扩展，输入扩展名字，查找。</p>
<img src="http://tva3.sinaimg.cn/large/7d4c6366gy1gi1x3ifk4dj20qq0h8t9w.jpg" width="700" align="bottom">
<center>PECL官网</center>

<p>从查找结果列表中找到redis扩展。</p>
<img src="http://tva4.sinaimg.cn/large/7d4c6366gy1gi1x3nmocfj20qq0gddgk.jpg" width="700" align="bottom">
<center>查找结果列表</center>

<p>点击进入，看到有不同版本的redis扩展。</p>
<blockquote>
<p>注意要找稳定版(statble)的DLL。</p>
</blockquote>
<img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gi1z0970g7j20lf0o6juk.jpg" width="700" align="bottom">
<center>不同版本的redis扩展</center>


<p>根据第一步确定的信息，可以找到目标扩展，点击下载。</p>
<img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gi1x3rvy3qj20qq0prmz3.jpg" width="700" align="bottom">
<center>目标扩展</center>

<h3><span id="an-zhuang-kuo-zhan">安装扩展</span><a href="#an-zhuang-kuo-zhan" class="header-anchor">#</a></h3><p>解压缩扩展文件，把DLL扩展文件放到PHP扩展文件夹里面。</p>
<blockquote>
<p>如果不知道PHP扩展文件夹的位置，从php.ini里搜索extension_dir&#x3D;”…”可以找到。</p>
</blockquote>
<p>在php.ini文件里添加</p>
<blockquote>
<p>extension&#x3D;php_redis.dll</p>
</blockquote>
<p>即可。</p>
<h3><span id="ce-shi">测试</span><a href="#ce-shi" class="header-anchor">#</a></h3><p>重启服务器，访问 <strong>phpinfo.php</strong> ，如果看到有目标扩展信息，即表示安装成功。<br><img src="http://tva2.sinaimg.cn/large/7d4c6366gy1gi1x40ful0j20q903ut8k.jpg" width="700" align="bottom"></p>
<center>测试redis扩展</center>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/08/08/dananshan/">穿越大南山</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-08-08T19:00:00.000Z" itemprop="datePublished">Aug 9, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/爬山/">爬山</a> <a href="/tags/游玩/">游玩</a>
</div>
    </div>
      
        <p><audio src="http://music.163.com/song/media/outer/url?id=27483202.mp3" controls autoplay loop preload="auto">任我行——陈奕迅</audio></p>
<p>第一次看到大南山的图片是蓝蓝的天空，厚厚的白云，绿油油的草原，颇有几分大西北的感觉，如果有多几只牛羊，以假乱真足矣。这如画的风景不去可惜了，于是叫上朋友一起报名，参加了8月8日周六的活动。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkwg9mkprj31400u04qr.jpg" width="700" align="bottom">

<p>大南山位于惠州市惠东县与汕尾市海丰县接壤的地带，此地群峰耸峙，林深壑幽，山腰白练飘飘，山下溪涧奔流。<br>三五村落散布其间，恍若桃源。因有著名的南山寺、南山河，故统称南山。</p>
<p>当天上午7:30出发，经过3个多小时的车程，到达惠东县南山村，下车后集体做热身动作，将近11点的时候，开始进山。</p>
<p>进山首先就遇到上坡，虽然坡度不陡，但是一开始连续上坡的话可能会造成身体不适，所以领队也建议走一段歇一段，让身体逐渐进入状态。</p>
<p>大概12点的时候到达午餐点（此时还没走3公里），午餐点是一条较为平坦的土路，路面铺满了枯萎的落叶。<br>路两边长有很高的树，把中午的阳光都挡住了，感觉阴凉。<br>大家纷纷在路的两旁挨着树坐下，先到的在前面，后到的坐后面，如此一排坐下去。<br>领队切好了西瓜，就沿着两边一个一个分过去。</p>
<p>午餐既丰富又有惊喜，同行的小伙伴们纷纷拿出了“珍藏”，发挥户外分享精神，有提子、小番茄、青瓜。<br>有的小伙伴热情的很，端着盒小番茄一个人一个人的问过去：“吃一个，吃一个”。</p>
<p>冰镇西瓜基本是标配，令我感到惊喜的是领队还带了私家辣条和冰镇可乐，顿时引起一阵骚动。</p>
<blockquote>
<p>要知道什么时候的可乐最好喝，肯定是运动后，大汗淋漓，筋疲力尽，可乐犹如催化剂一般将你激活。</p>
</blockquote>
<p>相比较而言我带的冬枣和青柑不太受欢迎，但我觉得也不错啊。<br>一巡吃下来，差不多有五六分饱了，手上的八宝粥也不“香”了，但为了后面不至于体力下降，还是把八宝粥吃了下去。</p>
<p>酒足饭饱好赶路，短暂休整后就开始跟着前队出发了。</p>
<p>因为刚吃东西不久，所以行进的速度也没敢太快，就当作散步那样慢走。没多久就走出了丛林，来到了令人找不到北的茅草荡前。</p>
<p>茅草长得又高又密，刚进去手指就被割了，虽然流了点血，不过也仅仅是皮外伤，无大碍。<br>领队说的要武装到牙齿，应该就是指这一段吧！<br>庆幸的是，这一段不用五分钟就穿过了。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqqbyy51j31400u0e83.jpg" width="700" align="bottom">
<center>茅草荡</center>


<p>因为在茅草荡里都是弯腰低头走路的，所以出来的第一个感觉就像重见天日一般，不仅如此，还看到了接下来要上的第一个急升坡，像一块绿色的毯子一样挂在那里，第一次如此亲近草原，迫不及待来一张。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqqzj0r1j30u0140e83.jpg" width="700" align="bottom">

<p>终于来到第一座山前面，装好水就开始上山了。这一座山爬升高度有400多米，由半山腰的一个平台分成两节。</p>
<p>上第一节的时候，我们已经被前队的人甩掉了，自然的就变成了中队的人。<br>爬升没一会儿就开始喘息，在山脊上稍站了一下，发现完全没风，而且还很闷热，于是就继续跟着爬升，想着尽快到达平台。</p>
<p>在快要到达平台的时候，感觉到呼吸不畅，有呕吐的感觉，于是才马上停下来，大口呼吸，努力让心率降下来。<br>经过调整节奏，放缓速度，最后才颤巍巍的到达平台，没有被领队拉爆，自己反而“爆了”，策略错误。</p>
<blockquote>
<p>所以说，无论是爬山还是跑步，都要时刻关注自己的呼吸，重视身体给出的信号，要根据当前的体力情况来调整速度和节奏。<br>切莫盲目的跟着前面的人或者跟别人比拼耐力，也不要因为挡到后面的人而强忍着继续前进。</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqs5lpifj31dz0u01l2.jpg" width="700" align="bottom">
<center>第一座山 山底</center>

<p>到达第一座山顶峰后，累得直接坐下来，顺手把刚刚吃剩下的提子小番茄冬枣和青柑拿出来，做一轮补充，顺便也减一下负。</p>
<p>没过多久尾队的领队也到了，我和我朋友都惊呆了！<br>我们跟着前队出发，和中队一起上山，最后在山顶休息，变成了尾队。我“断后大师”的小目标实现得太突然了。<br>于是赶紧收拾东西，撇了。</p>
<p>一段短暂的下坡后就下山了，接着就是3公里的机耕路。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkprnacfej31400u07wj.jpg" width="700" align="bottom">
<center>第一座山 山顶</center>

<p>机耕路好走很多了，我加快了脚步想要去追中队。但是发现朋友速度没跟上，或许是刚刚的上坡太猛还没恢复，在确定了水量和食物足够后，我就先去追中队了。</p>
<p>连走带跑的追到中队伍并且超过了中队的领队，赶在15点前到达第二座山下。</p>
<blockquote>
<p>后来才意识到，其实不用那么赶的，如果体力足够的话，领队也不会阻止你登顶的。设置关门时间，可能是想给一些想要提前下撤的队友多一个选择，或者说是帮他们做一个选择，当然最重要的还是自己决定。</p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqi1wegdj30u01401l0.jpg" width="700" align="bottom">
<center>机耕路</center>

<p>短暂的休息，喝水，装水后，开始上第二座山。</p>
<p>第二座山爬升高度有100多米，由山腰的一个平台分成两节。</p>
<p>这一次格外注意上升速度，累了就歇，避免再次出现身体不适。<br>行走在山脊上，同样的无风，闷热。<br>走累了就停一下，一停下来就感觉到身体不断的在散发热量，汗水滴在乱石上，一下子就不见了，所以停下来好像也没舒服多少。<br>只能集中精神，忍着慢慢上。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqigogzij30u0140x6p.jpg" width="700" align="bottom">
<center>第二座山 山底</center>

<p>终于到达山腰的平台，队友们聚集在悬崖边聊天、看风景、补充食物。</p>
<p>一阵风吹来，大家都安静了。微风带走身体多余的热量，带走暑气，舒服，沁人心脾。</p>
<p>在平台上眺望那条长长的机耕路，看到三三两两的人群，回想起刚刚一个人连走带跑的情景，心想我刚刚是否走太快了？以至于遗落了一些什么东西。</p>
<blockquote>
<p>但生活中不就是这样吗？总是为了实现一个目标一条路走到黑，而忽略了过程中的美景，这注定无法兼得。</p>
</blockquote>
<p>陈老师说：“我知道草原上又扬起微风，就该要说再见”。</p>
<p>是的，感谢微风带走疲倦，我还要赶路，再见。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqk61olqj31400u01ky.jpg" width="700" align="bottom">
<center>第二座山 平台</center>

<p>第二节爬升高度大约50米，难度不大，不用15分钟就登顶了。</p>
<p>顶峰——斧头石，无遮无挡，明显更晒，但风景却最好。</p>
<p>往前看，可以看到大海，那是惠州的内海湾，惠州海湾大桥横跨南北两岸；<br>左边是一片低矮的山地，散布着村落，还有几根大烟囱，冒着浓浓白烟；<br>右边是陡峭的悬崖，还有连绵不绝的山脉；<br>后面正是来时的路，陡峭的山脊直通山脚下，远处则是那条如黄色丝带般的机耕路，连接着两座高山。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqktwatnj31400u0qv7.jpg" width="700" align="bottom">
<center>第二座山 山顶</center>

<p>正当休息的时候，意外发现朋友就在下面的平台，正在往上面走。最后能一起登顶当然是最好的结果，也是最开心的事情。</p>
<p>大约16点的时候，尾队的小伙伴全部登顶了，拍了个大合照，我们就先下撤了。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkqlxakwbj31400u0af5.jpg" width="700" align="bottom"></p>
<center>大合照</center>

<p>下撤路是一条长长的下坡路（如下海拔图，从最高点一直到最低点），相对来说，下坡路容易一点，但需要一些技巧。<br>考虑到领队几次强调这一次下坡比较长，所以一开始就借用了朋友的一根登山杖并尝试使用，庆幸的是走到这里已经能熟练的借力登山杖了。</p>
<p>下山后在想，或许正因为有登山杖的帮助，我才能顺利的下山。<br>因为记得有几个地方是比较陡峭的黄土坡，黄土经过雨水的冲刷，变得湿润，踩上去极容易打滑，稍不留神就会摔屁股。登山杖就是在你打滑的时候给你一个支撑，留给你更多的反应时间。<br>由此也一改我以前对登山杖的看法。</p>
<blockquote>
<p>其实每个工具被创造出来，自有它的用处，如果你觉得没用，那可能是你还不会用，或者是还没用到它的时候。</p>
</blockquote>
<p>走过漫长的“绝望坡”，穿过狂野的乱石路，终于看到了大马路，终点就在眼前了。<br>最后自娱自乐的“冲刺”通过围栏，“恭喜第五名第六名选手完成穿越”。</p>
<img src="http://tva2.sinaimg.cn/large/7d4c6366gy1ghlspl2j1qj20yi0twwgg.jpg" width="700" align="bottom">
<center>路线海拔图</center>

<p>终于到达终点——大王庙，来到大王庙对面的小吃店歇息，此时啥也吃不下，整两碗糖水先。</p>
<p>小吃店有厕所可以免费洗澡，虽然条件简陋，但能把那身被汗水湿透的衣服换洗下来，已经很满足了。</p>
<p>接下来就是等待尾队的小伙伴下来，直到19点的时候，才看到尾队的领队，19:30全员上车，返回广州，大约22:30抵达客村地铁站，结束今天的行程。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkql7dmdkj31400u01ky.jpg" width="700" align="bottom"></p>
<center>小吃店</center>

<p>本次行程有14公里，累计爬升将近1000米，耗时6小时20分。<br>从南山村出发，登顶斧头石，最后安全到达大王庙。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkplfcccij30u00ymtaa.jpg" width="700" align="bottom"></p>
<center>轨迹图</center>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/08/01/radix-sort/">一种不需要比较的排序方法——基数排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-08-01T21:30:00.000Z" itemprop="datePublished">Aug 2, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>基数排序是一种借助于多关键字排序的思想对单关键字排序的方法。</p>
<blockquote>
<p>基数排序也有人称桶排序，因为借助于10个桶（0~9号桶）临时存放记录。</p>
</blockquote>
<p>基数排序算法通过若干次 $(loop)$ 分配和收集实现排序。$loop$ 值由最大的记录关键值的位数决定，例如待排序的表中，最大的记录关键值为100，那么 $loop$ 等于3，需要3次分配和收集才能实现有序表。</p>
<p>第一次分配，需要取 记录关键值的个位数 为索引值，存放到对应的桶里面，如果有相同的索引值，则按顺序存储。</p>
<p>第一次收集，需要按桶的索引值和桶里面记录值的顺序收集。</p>
<p>这样就完成了第一次分配和收集。</p>
<p>第二次、第三次分配收集也是按照这样的过程完成。</p>
<blockquote>
<p>一道使用基数排序解决的题 <a href="/2020/06/06/leetcode-128">leetcode 128h 最长连续序列</a></p>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghf8mu99ujj30u016fti8.jpg" width="700" align="bottom">

<h3><span id="xing-neng-ping-jie">性能评价</span><a href="#xing-neng-ping-jie" class="header-anchor">#</a></h3><p>时间复杂度：$O(n)$</p>
<p>稳定性：稳定</p>
<h3><span id="ji-shu-pai-xu-wan-zheng-dai-ma">基数排序完整代码</span><a href="#ji-shu-pai-xu-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType *p)</span>;</span><br><span class="line">RecType* <span class="title function_">generalPNode</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getMaxNum</span><span class="params">(RecType *p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetMaxLoop</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getBaseNum</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> numSt)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">(RecType **p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  基数排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    RecType *p;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    p =generalPNode(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;基数排序 ... \n&quot;</span>);</span><br><span class="line">    RadixSort(&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  构造基数排序存储结构</span></span><br><span class="line">RecType* <span class="title function_">generalPNode</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    RecType *p = <span class="literal">NULL</span>,*q = <span class="literal">NULL</span>,*tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = (RecType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RecType));</span><br><span class="line">        tmp-&gt;key = nums[i];</span><br><span class="line">        tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q = tmp;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;next = tmp;</span><br><span class="line">            q = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">(RecType **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = getMaxNum(*p);</span><br><span class="line">    <span class="type">int</span>	loop = GetMaxLoop(max);</span><br><span class="line"></span><br><span class="line">    RecType *head[<span class="number">10</span>],*tail[<span class="number">10</span>],*tmp;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= loop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  每次循环，先清空各个桶里的数据</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            head[j] = tail[j] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  分配</span></span><br><span class="line">        <span class="comment">//  把链表的分配到指定的桶里</span></span><br><span class="line">        <span class="comment">//  由于是链式存储，所以每个桶里的实际数据是head和tail指针之间的节点</span></span><br><span class="line">        <span class="keyword">while</span> ((*p) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = getBaseNum((*p)-&gt;key,i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (head[k] == <span class="literal">NULL</span>)</span><br><span class="line">                head[k] = (*p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tail[k]-&gt;next = (*p);</span><br><span class="line"></span><br><span class="line">            tail[k] = (*p);</span><br><span class="line">            (*p) = (*p)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  重置链表</span></span><br><span class="line">        (*p) = <span class="literal">NULL</span>;     </span><br><span class="line"></span><br><span class="line">        <span class="comment">//  收集</span></span><br><span class="line">        <span class="comment">//  各个桶里的实际数据是有head和tail指针确定的</span></span><br><span class="line">        <span class="comment">//  所以把各个桶按顺序，按照 tail-&gt;next = head 连接起来</span></span><br><span class="line">        <span class="comment">//  最后把 tail-&gt;next = NULL 就完成了收集工作</span></span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head[j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*p) == <span class="literal">NULL</span>)</span><br><span class="line">                    (*p) = head[j];    </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp-&gt;next = head[j];</span><br><span class="line">                tmp = tail[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回最大关键值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMaxNum</span><span class="params">(RecType *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key &gt; max) max = p-&gt;key;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回整数的位数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetMaxLoop</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> bits = <span class="number">1</span>;</span><br><span class="line">	num /= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++bits;</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回整数指定位序号的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getBaseNum</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> numSt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numTimes = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i,baseNum;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;numSt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numTimes *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    baseNum = num/numTimes%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> baseNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/31/merge-sort/">归并排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-31T21:30:00.000Z" itemprop="datePublished">Aug 1, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>归并排序简单的来说是把两个有序表合并成一个有序表。</p>
<p>一开始从规模最小的只有1个记录的两个表开始合并，使待排序表局部有序。<br>随着记录规模的扩大，待排序表从局部有序逐渐变成整体有序。</p>
<blockquote>
<p>每一次循环的规模都遵循2倍数扩大，从一开始的1个记录，到2、4、8、…，递增。</p>
</blockquote>
<p>每一次归并排序都需要借助开辟的存储空间来保存合并后的有序表，然后再复制到原来的表上，不能在原来的表上直接操作。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghf8kk991yj30u016fjyp.jpg" width="700" align="bottom">

<h3><span id="xing-neng-ping-jie">性能评价</span><a href="#xing-neng-ping-jie" class="header-anchor">#</a></h3><p>时间复杂度：$O(nlog_2n)$</p>
<p>稳定性：稳定</p>
<h3><span id="gui-bing-pai-xu-wan-zheng-dai-ma">归并排序完整代码</span><a href="#gui-bing-pai-xu-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortWithLength</span><span class="params">(RecType R[],<span class="type">int</span> length,<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;归并排序 ... \n&quot;</span>);</span><br><span class="line">    MergeSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (length &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        MergeSortWithLength(R,length,n);</span><br><span class="line">        length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortWithLength</span><span class="params">(RecType R[],<span class="type">int</span> length,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;                  <span class="comment">//  第一个有序数组开始下标   </span></span><br><span class="line">    <span class="type">int</span> k = i + length - <span class="number">1</span>;     <span class="comment">//  第一个有序数组结束下标           </span></span><br><span class="line">    <span class="type">int</span> j = i + <span class="number">2</span>*length - <span class="number">1</span>;   <span class="comment">//  第二个有序数据结束下标</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(R,i,k,j);</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">        k = i + length - <span class="number">1</span>;</span><br><span class="line">        j = i + <span class="number">2</span>*length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩下至少有 length 个记录，才需要整理排序</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(R,i,k,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  合并两个有序数组成一个有序数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = left,j = mid + <span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    RecType *tmp = (RecType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RecType) * (right-left+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">        <span class="keyword">if</span>(R[i].key &lt; R[j].key)</span><br><span class="line">            tmp[k++] = R[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = R[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = R[i++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        tmp[k++] = R[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>,i = left; i&lt;=right; i++,k++)</span><br><span class="line">        R[i] = tmp[k]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/29/select-sort/">选择排序——直接选择排序、堆排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-29T21:30:00.000Z" itemprop="datePublished">Jul 30, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>每一趟从待排序的记录中选出关键字最小的记录，顺序放在已排好序的子表的最后，直到全部记录排序完毕。 </p>
<h3><span id="liang-chong-xuan-ze-pai-xu-fang-fa">两种选择排序方法</span><a href="#liang-chong-xuan-ze-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>直接选择排序</li>
<li>堆排序</li>
</ol>
<h3><span id="zhi-jie-xuan-ze-pai-xu">直接选择排序</span><a href="#zhi-jie-xuan-ze-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>设有n个元素，则需要n-1次循环。<br>每次循环通过两两对比，找到关键值最小的记录，经过n-1次循环后则可以得到一个有序的序列。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  R[i]的关键值与R[j]的关键值逐个比较，每次把较小的赋值给R[i]</span></span><br><span class="line">            <span class="comment">//  存在交换多次的问题</span></span><br><span class="line">            <span class="keyword">if</span>(R[i].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[i];</span><br><span class="line">                R[i] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：非稳定</p>
<h3><span id="zhi-jie-xuan-ze-pai-xu-you-hua-ban">直接选择排序 优化版</span><a href="#zhi-jie-xuan-ze-pai-xu-you-hua-ban" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>直接选择排序在每一次找到最小值的过程中，需要进行多次关键值比较。<br>若比较结果成立，则记录的位置互换（执行赋值操作）。<br>例如要求关键字序列：<code>9 8 7 6 5</code> 按递增顺序显示，程序的第一次遍历结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;   9 8 7 6 5 </span><br><span class="line">2&gt;   8 9 7 6 5</span><br><span class="line">3&gt;   7 9 8 6 5</span><br><span class="line">4&gt;   6 9 8 7 5</span><br><span class="line">5&gt;   5 9 8 7 6</span><br></pre></td></tr></table></figure>

<p>很明显，第一次遍历找到的最小值应该是 <code>5</code>，但是找到最小值过程中，发生了多次无用的赋值操作（第2、3、4行）。<br>为了减少时间复杂度，在比较的过程中，使用一个变量保存最小值的索引值，直到与最后一个元素比较后，才执行赋值操作。优化后的程序第一次遍历的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt;   9 8 7 6 5 </span><br><span class="line">2&gt;   5 9 8 7 6</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  选择排序 优化版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  默认第一个元素是最小的</span></span><br><span class="line">        k = i;      </span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(R[k].key &gt; R[j].key)</span><br><span class="line">                k = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  最后做一次比较，不相等则互相交换</span></span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[k];</span><br><span class="line">            R[k] = R[i];</span><br><span class="line">            R[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：非稳定</p>
<h3><span id="zhi-jie-xuan-ze-pai-xu-dai-ma">直接选择排序代码</span><a href="#zhi-jie-xuan-ze-pai-xu-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序 ... \n&quot;</span>);</span><br><span class="line">    SelectSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序 改进版... \n&quot;</span>);</span><br><span class="line">    SelectSort_v2(R,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  R[i]的关键值与R[j]的关键值逐个比较，每次把较小的赋值给R[i]</span></span><br><span class="line">            <span class="comment">//  存在交换多次的问题</span></span><br><span class="line">            <span class="keyword">if</span>(R[i].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[i];</span><br><span class="line">                R[i] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  默认第一个元素是最小的</span></span><br><span class="line">        k = i;      </span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(R[k].key &gt; R[j].key)</span><br><span class="line">                k = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  最后做一次比较，不相等则互相交换</span></span><br><span class="line">        <span class="keyword">if</span>(i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[k];</span><br><span class="line">            R[k] = R[i];</span><br><span class="line">            R[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="dui-pai-xu">堆排序</span><a href="#dui-pai-xu" class="header-anchor">#</a></h3><p><strong>完全二叉树简介</strong></p>
<p>使用待排序 关键值序列 构建一棵完全二叉树，然后从上到下，从左到右，按顺序给完全二叉树编号。</p>
<blockquote>
<p>使用顺序存储结构，所以物理编号为 $0$ 的位置为空，从物理编号为 $1$ 的位置开始保存关键值。</p>
</blockquote>
<p>根据完全二叉树的性质可知：</p>
<ol>
<li>若编号为 $i$ 的节点为分支节点，则 $2i$ 为左子节点，$2i+1$ 为右子节点；</li>
<li>若编号为 $i$ 的节点有父节点，则父节点编号为 $floor(\frac {i} {2})$ ；</li>
<li>若完全二叉树有 $n$ 个节点，则编号最大的分支节点为 $floor(\frac {n}{2})$ ；</li>
</ol>
<p><strong>堆的定义</strong></p>
<p>$n$ 个关键字序列 $K_1,K_2,…,K_n$ 称为堆，当且仅当该序列满足如下性质：</p>
<ol>
<li>$K_i&lt;&#x3D;K_{2i}$ 且 $K_i&lt;&#x3D;K_{2i+1}$ </li>
<li>或 $K_i&gt;&#x3D;K_{2i}$ 且 $K_i&gt;&#x3D;K_{2i+1}$<br>$(1&lt;&#x3D;i&lt;&#x3D;floor(\frac {n}{2}))$</li>
</ol>
<p>堆可分为小根堆和大根堆：</p>
<ol>
<li>小根堆：根节点关键值 <strong>小于等于</strong> 左右子节点关键值的堆；</li>
<li>大根堆：根节点关键值 <strong>大于等于</strong> 左右子节点关键值的堆；</li>
</ol>
<p><strong>基本思想</strong></p>
<p>从编号最大的分支节点开始（编号为 $floor(\frac {n}{2})$ ），<strong>最大堆化</strong> 每一棵树，直到根节点结束。<br>此时得到一个最大堆，因为最大堆的根节点关键值最大，所以保存根节点，然后使用最有一个叶子节点赋值给根节点，继续堆化，直到最后一个节点结束。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Heapify(R,i,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[j];</span><br><span class="line">        R[j] = R[<span class="number">1</span>];</span><br><span class="line">        R[<span class="number">1</span>] = tmp;</span><br><span class="line">        Heapify(R,<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  最大堆化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    tmp = R[p];</span><br><span class="line">    i = p;</span><br><span class="line">    j = <span class="number">2</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个子节点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  有两个子节点则找到较大的那个</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n &amp;&amp; R[j].key &lt; R[j+<span class="number">1</span>].key) j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  父节点比子节点小，则子节点“上浮”到父节点，并且继续堆化</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(nlog_2n)$</p>
<p>稳定性：非稳定</p>
<h3><span id="dui-pai-xu-wan-zheng-dai-ma">堆排序完整代码</span><a href="#dui-pai-xu-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i+<span class="number">1</span>].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆排序... \n&quot;</span>);</span><br><span class="line">    HeapSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i+<span class="number">1</span>].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        Heapify(R,i,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[j];</span><br><span class="line">        R[j] = R[<span class="number">1</span>];</span><br><span class="line">        R[<span class="number">1</span>] = tmp;</span><br><span class="line">        Heapify(R,<span class="number">1</span>,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  堆化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(RecType R[],<span class="type">int</span> p,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    tmp = R[p];</span><br><span class="line">    i = p;</span><br><span class="line">    j = <span class="number">2</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个子节点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  有两个子节点则找到较大的那个</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n &amp;&amp; R[j].key &lt; R[j+<span class="number">1</span>].key) j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  父节点比子节点小，则子节点“上浮”到父节点，并且继续堆化</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/28/swap-sort/">交换排序——冒泡排序、快速排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-28T21:30:00.000Z" itemprop="datePublished">Jul 29, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。 </p>
<h3><span id="liang-chong-jiao-huan-pai-xu-fang-fa">两种交换排序方法</span><a href="#liang-chong-jiao-huan-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>冒泡排序</li>
<li>快速排序</li>
</ol>
<h3><span id="mou-pao-pai-xu">冒泡排序</span><a href="#mou-pao-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>把待排序记录在逻辑上分成有序区和无序区，一开始有序区没有记录，无序区有 $n$ 个记录。</p>
<p>通过无序区中相邻记录关键字间的比较和位置的交换，使关键字最小的记录如气泡一般逐渐往上<strong>漂浮</strong> 直至 <strong>水面</strong>。<br>$n$ 个元素排序，需要 $n-1$ 趟冒泡，有序区逐渐扩大到全局有序。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="mou-pao-pai-xu-you-hua-ban">冒泡排序 优化版</span><a href="#mou-pao-pai-xu-you-hua-ban" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>无序区中记录 <strong>冒泡</strong> 的过程，会逐渐把无序区里的记录变得有序，所以假如有 $n$ 个无序记录，一般情况下不需要 $n-1$ 趟冒泡就可以使全局达到有序。</p>
<p>普通冒泡排序，需要9趟冒泡排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序前：1 4 6 8 0 2 5 7 9 3 </span><br><span class="line">冒泡排序 ... </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">排序后：0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure>

<p>优化版冒泡排序，需要6趟冒泡排序就可以使全局记录有序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序前：1 4 6 8 0 2 5 7 9 3 </span><br><span class="line">冒泡排序 改进版 ... </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">排序后：0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  冒泡排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="kuai-su-pai-xu">快速排序</span><a href="#kuai-su-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>在待排序的 $n$ 个记录中任取一个记录（通常取第一个记录）作为基准，把该记录放入适当位置后，数据序列被此记录划分成两部分，分别是比基准小和比基准大的记录。再对基准两边的序列用同样的策略进行操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  快速排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    RecType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  至少两个元素参与排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一个元素最为基准元素</span></span><br><span class="line">    tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[j].key &gt;= tmp.key)</span><br><span class="line">            j--;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i].key &lt;= tmp.key)</span><br><span class="line">            i++;</span><br><span class="line">        R[j] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  基准元素找到了正确位置</span></span><br><span class="line">    R[i] = tmp;</span><br><span class="line">    QuickSort(R,left,i<span class="number">-1</span>);</span><br><span class="line">    QuickSort(R,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(nlog_2n)$</p>
<p>稳定性：不稳定</p>
<h3><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  交换排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序 ... \n&quot;</span>);</span><br><span class="line">    BubbleSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序 改进版 ... \n&quot;</span>);</span><br><span class="line">    BubbleSort_v2(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;快速排序 ... \n&quot;</span>);</span><br><span class="line">    QuickSort(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  冒泡排序 改进版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort_v2</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">//  n个记录，外层循环需要遍历n-1次，最后一个记录自然有序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (R[j<span class="number">-1</span>].key &gt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = R[j];</span><br><span class="line">                R[j] = tmp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  快速排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(RecType R[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    RecType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  至少两个元素参与排序</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一个元素最为基准元素</span></span><br><span class="line">    tmp = R[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[j].key &gt;= tmp.key)</span><br><span class="line">            j--;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i].key &lt;= tmp.key)</span><br><span class="line">            i++;</span><br><span class="line">        R[j] = R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  基准元素找到了正确位置</span></span><br><span class="line">    R[i] = tmp;</span><br><span class="line">    QuickSort(R,left,i<span class="number">-1</span>);</span><br><span class="line">    QuickSort(R,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/27/insert-sort/">插入排序——直接插入排序、希尔排序</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-27T21:30:00.000Z" itemprop="datePublished">Jul 28, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor">#</a></h3><p>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子表中的适当位置，直到全部记录插入完成为止。</p>
<h3><span id="liang-chong-cha-ru-pai-xu-fang-fa">两种插入排序方法</span><a href="#liang-chong-cha-ru-pai-xu-fang-fa" class="header-anchor">#</a></h3><ol>
<li>直接插入排序</li>
<li>希尔排序</li>
</ol>
<h3><span id="zhi-jie-cha-ru-pai-xu">直接插入排序</span><a href="#zhi-jie-cha-ru-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>假设待排序的记录存放在数组 $R[0…n-1]$中，排序过程的某一中间时刻，$R$ 被划分成两个子区间 $R_1[0…i-1]$ 和 $R_2[i…n-1]$ ，其中$R_1$ 为有序区（默认只有第一个元素），$R_2$ 为无序区。<br>直接插入排序的基本操作是将当前无序区的第1个记录 $R_2[i]$ 插入到有序区 $R_1[0…i-1]$ 中适当的位置上，使 $R_1[0…i]$ 变为新的有序区。<br>直接插入排序每次使有序区增加1个记录，故常称为增量法。</p>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：稳定</p>
<h3><span id="zhe-ban-cha-ru-pai-xu">折半插入排序</span><a href="#zhe-ban-cha-ru-pai-xu" class="header-anchor">#</a></h3><p><strong>基本思想</strong></p>
<p>折半插入排序算法的步骤可分为三步：</p>
<ol>
<li>通过折半查找，找到 $R_2[i]$ 的位置；</li>
<li>移动有序区 $R_1[0…i-1]$ 中的元素，给 $R_2[i]$ 空出一个位置；</li>
<li>$R_2[i]$ 赋值到正确的位置</li>
</ol>
<p>因为 $R_2[i]$ 在有序区 $R_1[0…i-1]$ 中的位置是一定的，所以折半插入排序的元素移动次数与直接插入排序相同，不同的是找到该位置的计算量不同。</p>
<p>因为折半插入排序使用了折半查找，计算次数上肯定会少于使用顺序查找的直接插入排序，所以性能上有一定的优势。</p>
<blockquote>
<p>折半插入排序是直接插入排序的改进版。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> left,mid,right;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.key &lt; R[mid].key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=right+<span class="number">1</span>;j--)</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">        </span><br><span class="line">        R[right+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^2)$</p>
<p>稳定性：不稳定</p>
<h3><span id="xi-er-pai-xu">希尔排序</span><a href="#xi-er-pai-xu" class="header-anchor">#</a></h3><p><strong>介绍</strong></p>
<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<blockquote>
<p>希尔排序按其设计者 Donald Shell 的名字命名，该算法由1959年公布。</p>
</blockquote>
<p><strong>基本思想</strong></p>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步。<br>然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p>
<blockquote>
<p>Donald Shell最初建议步长选择为 $\frac{n}{2}$，并且每一次循环对步长取半，直到步长达到 $1$。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    gap = n/<span class="number">2</span>;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap] = R[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能评价</strong></p>
<p>时间复杂度：$O(n^{1.3})$</p>
<p>稳定性：不稳定</p>
<h3><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType data;</span><br><span class="line">&#125; RecType;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    KeyType a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    RecType R[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        R[i].key = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;直接插入排序 ... \n&quot;</span>);</span><br><span class="line">    InsertSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;折半插入排序 ... \n&quot;</span>);</span><br><span class="line">    BinInsertSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shell插入排序 ... \n&quot;</span>);</span><br><span class="line">    ShellSort(R,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    DisRecType(R,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisRecType</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,R[i].key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;    </span><br><span class="line">        R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> left,mid,right;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = R[i];</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.key &lt; R[mid].key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=right+<span class="number">1</span>;j--)</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">        </span><br><span class="line">        R[right+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shell插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecType R[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,gap;</span><br><span class="line">    gap = n/<span class="number">2</span>;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = R[i];</span><br><span class="line">            j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.key &lt; R[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[j+gap] = R[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            R[j+gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/26/sort/">排序算法简介</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-26T21:30:00.000Z" itemprop="datePublished">Jul 27, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/排序/">排序</a>
</div>
    </div>
      
        <h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>整理“表”中的记录，使之按关键字递增（或递减）有序排列。</p>
<p>例如输入：</p>
<p>$n$ 个记录 $[R_0,R_1,R_2,…R_{n-1}]$，</p>
<p>关键字为 $[K_1,K_2,K_3,…K_{n-1}]$</p>
<p>经过排序…</p>
<p>输出：</p>
<p>$[R_{i0},R_{i1},R_{i2},…R_{in-1}]$，</p>
<p>使得 $[k_{i0}&lt;&#x3D;k_{i1}&lt;&#x3D;k_{i2}&lt;&#x3D;…&lt;&#x3D;k_{in-1}]$</p>
<p>（或者 $[k_{i0}&gt;&#x3D;k_{i1}&gt;&#x3D;k_{i2}&gt;&#x3D;…&gt;&#x3D;k_{in-1}]$）</p>
<h3><span id="pai-xu-suan-fa-de-xing-neng-ping-jie">排序算法的性能评价</span><a href="#pai-xu-suan-fa-de-xing-neng-ping-jie" class="header-anchor">#</a></h3><p>分别通过 <a href="/2020/06/01/time-complexity-algorithm#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6">算法复杂度</a> 和 算法稳定性 来评价排序算法的性能优劣。</p>
<p><strong>算法稳定性</strong></p>
<p>当待排序记录的关键字均不相同时，排序的结果是惟一的，也是稳定的。</p>
<p>如果待排序的表中，存在有多个关键字相同的记录：假如经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是稳定的；<br>反之，若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。</p>
<h3><span id="pai-xu-suan-fa-fen-lei">排序算法分类</span><a href="#pai-xu-suan-fa-fen-lei" class="header-anchor">#</a></h3><ol>
<li><a href="/2020/07/28/insert-sort">插入排序</a><ul>
<li>直接插入</li>
<li>希尔排序</li>
</ul>
</li>
<li><a href="/2020/07/30/select-sort">选择排序</a><ul>
<li>直接选择</li>
<li>堆排序</li>
</ul>
</li>
<li><a href="/2020/07/29/swap-sort">交换排序</a><ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li><a href="/2020/08/01/merge-sort">归并排序</a></li>
<li><a href="/2020/08/02/radix-sort">基数排序</a></li>
</ol>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/21/BST/">二叉查找树(BST)</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-21T05:00:00.000Z" itemprop="datePublished">Jul 21, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/数据结构/">数据结构</a> <a href="/tags/查找/">查找</a>
</div>
    </div>
      
        <h3><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor">#</a></h3><p>一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点；</li>
</ol>
<blockquote>
<p>二叉查找树又称为二叉搜索树，简称 <strong>BST</strong></p>
</blockquote>
<div style="display: flex;">
    <div float="left">
    <img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gh1x081xtmj20ab06zt8s.jpg" alt="二叉查找树" align="bottom">
    <center>图1 二叉查找树</center>
    </div>
    <div float="right">
    <img src="http://tvax1.sinaimg.cn/large/7d4c6366gy1gh1x0faozej20ab06zmxa.jpg" alt="非二叉查找树" align="bottom">
    <center>图2 非二叉查找树</center>
    </div>
</div>

<p>根据 <strong>BST</strong> 的性质，中序遍历图1，可得到一个有序的序列 <code>1 2 3 4 5 6 7</code>。</p>
<h3><span id="chuang-jian-bst">创建BST</span><a href="#chuang-jian-bst" class="header-anchor">#</a></h3><p>通过关键字序列来创建 <strong>BST</strong> 。</p>
<p>当二叉树为空时，把第一个节点当作根节点。<br>当二叉树不为空时，插入的值与根节点的值比较：</p>
<ol>
<li>若等于根节点的值，则丢弃该插入值；</li>
<li>若大于根节点的值，则插入以右子节点为根节点的二叉树中；</li>
<li>若小于根节点的值，则插入以左子节点为根节点的二叉树中；</li>
</ol>
<p>直到（左 或 右）子节点为空时，把插入值当作（左 或 右）子节点插入到二叉树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由有n个元素的数组A，创建一个二叉排序树</span></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt=<span class="literal">NULL</span>;                  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">            bt = GenerateNode(A[i]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            InsertBST(bt,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *tmp=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    tmp-&gt;key=k;</span><br><span class="line">    tmp-&gt;lchild=tmp-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p所指向的二叉排序树中，插入值为k的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)                 <span class="comment">//树中存在相同关键字的结点,返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)            <span class="comment">//插入到p的左子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">//插入到p的右子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;rchild,k); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="cha-zhao-jie-dian">查找节点</span><a href="#cha-zhao-jie-dian" class="header-anchor">#</a></h3><p>查找节点是创建 <strong>BST</strong> 的目的，查找的过程与创建的过程类似。</p>
<p>从根节点开始比较节点的关键字与目标值 $k$ （例如 $k&#x3D;5$ ）的大小，若比较结果相等则查找完成；<br>若不相等，再根据 $k$ 与该根节点关键字的比较大小确定下一步查找哪个子树。<br>递归进行下去，直到找到满足条件的节点或者该二叉树中没有这样的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在bt指向的节点为根的排序二叉树中，查找值为k的节点。找不到返回NULL</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span> || bt-&gt;key==k)         <span class="comment">//递归终结条件</span></span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="shan-chu-jie-dian">删除节点</span><a href="#shan-chu-jie-dian" class="header-anchor">#</a></h3><blockquote>
<p>删除节点的前提是二叉树有这个节点，所以在执行删除节点方法前，需用查找节点方法判定一下。</p>
</blockquote>
<p>通过关键值对比，找到了目标节点。</p>
<ol>
<li>若目标节点没有右子节点，则可能含有左子节点，则把目标节点的左子节点赋值给它自己；</li>
<li>若目标节点没有左子节点，则可能含有右子节点，则把目标节点的右子节点赋值给它自己；</li>
<li>若目标节点是双分支节点，则先找到左子节点 <strong>tmpchild</strong> ，此时分两种情况：<ul>
<li>若 <strong>tmpchild</strong> 没有右子节点，则 <strong>tmpchild</strong> 的值域为左子树中的最大值，把 <strong>tmpchild</strong> 的值域赋值给目标节点，然后释放 <strong>tmpchild</strong> 节点内存即可；</li>
<li>若 <strong>tmpchild</strong> 有右子节点，则找到 <strong>tmpchild</strong> 最大深度的右子节点，该节点的值域为左子树中的最大值，赋值给目标节点，释放内存即可。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除二叉搜索树中的一个节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>  <span class="comment">//在bt中删除关键字为k的结点</span></span><br><span class="line">&#123;   </span><br><span class="line">    BSTNode *tmpchild,*p;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt-&gt;key != k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = bt;                             <span class="comment">//  记录目标节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; bt-&gt;key)                     <span class="comment">//  往左找</span></span><br><span class="line">                bt = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; bt-&gt;key)               <span class="comment">//  往右找</span></span><br><span class="line">                bt = bt-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rchild == <span class="literal">NULL</span>)                  <span class="comment">//  目标节点无右孩子节点，则目标节点可能有左节点（左节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span>)             <span class="comment">//  目标节点无左孩子节点，则目标节点可能有右节点（右节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">//  目标节点有左右孩子节点，找到左子树的最大的右孩子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpchild = bt-&gt;lchild;              <span class="comment">//  左子树节点</span></span><br><span class="line">            <span class="keyword">if</span>(tmpchild-&gt;rchild == <span class="literal">NULL</span>)        <span class="comment">//  当左子树没有右孩子节点，则左子树节点就是 用来替换目标节点的 最大节点，</span></span><br><span class="line">            &#123;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;</span><br><span class="line">                bt-&gt;lchild = tmpchild-&gt;lchild;   <span class="comment">//  删除左子树节点，此时左子树节点没有右孩子节点，可能有左孩子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//  左子树节点有右孩子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (tmpchild-&gt;rchild != <span class="literal">NULL</span>)    <span class="comment">//  找到最大深度的右孩子节点，就是值最大的节点，并且记录它的父节点</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    p = tmpchild;</span><br><span class="line">                    tmpchild = tmpchild-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;            <span class="comment">//  替换目标节点的值</span></span><br><span class="line">                p-&gt;rchild = tmpchild-&gt;lchild;       <span class="comment">//  此时的 tmpchild 一定没有右子节点，但可能有左子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="xing-neng-ping-jie">性能评价</span><a href="#xing-neng-ping-jie" class="header-anchor">#</a></h3><p>当二叉搜索树上的节点均匀分布的时候（例如图1），二叉搜索树处于一个<strong>平衡的</strong>状态，此时的查找效率最高，时间复杂度为 $O(log_2n)$ 。<br>但是一般情况遇到的更多像图3这样的，甚至有像图4这样的最坏情况，时间复杂度达到 $O(n)$ ，像顺序查找一样。<br>所以 <strong>BST</strong> 的时间复杂度为[ $O(log_2n)$ , $O(n)$ ]。</p>
<div style="display: flex;">
    <div float="left">
    <img src="http://tva2.sinaimg.cn/large/7d4c6366gy1gh26jrf9qrj20bn09ndfz.jpg" alt="一般情况二叉查找树" align="bottom">
    <center>图3 一般情况二叉查找树</center>
    </div>
    <div float="right">
    <img src="http://tva1.sinaimg.cn/large/7d4c6366gy1gh25llq1swj20bn0hn3yw.jpg" alt="最坏情况二叉查找树" align="bottom">
    <center>图4 最坏情况二叉查找树</center>
    </div>
</div>

<h3><span id="wan-zheng-c-dai-ma">完整C代码</span><a href="#wan-zheng-c-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> InfoType[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>                 //记录类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;                    <span class="comment">//关键字项</span></span><br><span class="line">    InfoType data;                  <span class="comment">//其他数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBST</span><span class="params">(BSTNode *bt)</span>;</span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span>;</span><br><span class="line">BSTNode *<span class="title function_">SearchBST_unr</span><span class="params">(BSTNode *bt,KeyType k)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>;</span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  二叉查找树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt;</span><br><span class="line">    <span class="type">int</span> del_num;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">12</span>,x=<span class="number">46</span>;</span><br><span class="line">    KeyType a[]= &#123;<span class="number">25</span>,<span class="number">18</span>,<span class="number">46</span>,<span class="number">2</span>,<span class="number">53</span>,<span class="number">39</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">60</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    bt=CreateBST(a,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BST:&quot;</span>);</span><br><span class="line">    DispBST(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除%d结点\n&quot;</span>,x);</span><br><span class="line">    <span class="keyword">if</span> (SearchBST(bt,x) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   <span class="comment">//  结果 ！= NULL 表示找到值域为x的节点</span></span><br><span class="line">        del_num = DeleteBST(bt,x);</span><br><span class="line">        <span class="keyword">if</span>(del_num)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成功删除结点 %d\n&quot;</span>,x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BST:&quot;</span>);</span><br><span class="line">        DispBST(bt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由有n个元素的数组A，创建一个二叉排序树</span></span><br><span class="line">BSTNode *<span class="title function_">CreateBST</span><span class="params">(KeyType A[],<span class="type">int</span> n)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *bt=<span class="literal">NULL</span>;                  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">            bt = GenerateNode(A[i]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            InsertBST(bt,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">GenerateNode</span><span class="params">(KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *tmp=(BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    tmp-&gt;key=k;</span><br><span class="line">    tmp-&gt;lchild=tmp-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p所指向的二叉排序树中，插入值为k的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBST</span><span class="params">(BSTNode *p,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)                 <span class="comment">//树中存在相同关键字的结点,返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)            <span class="comment">//插入到p的左子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;lchild,k);  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">//插入到p的右子树中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> InsertBST(p-&gt;rchild,k); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = GenerateNode(k);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//括号表示法输出一棵排序二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispBST</span><span class="params">(BSTNode *bt)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,bt-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild != <span class="literal">NULL</span> || bt-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);                        <span class="comment">//有孩子结点时才输出(</span></span><br><span class="line">            DispBST(bt-&gt;lchild);                <span class="comment">//递归处理左子树</span></span><br><span class="line">            <span class="keyword">if</span> (bt-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);  <span class="comment">//有右孩子结点时才输出,</span></span><br><span class="line">            DispBST(bt-&gt;rchild);                <span class="comment">//递归处理右子树</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);                        <span class="comment">//有孩子结点时才输出)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在bt指向的节点为根的排序二叉树中，查找值为k的节点。找不到返回NULL</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span> || bt-&gt;key==k)         <span class="comment">//递归终结条件</span></span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; bt-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;lchild,k);  <span class="comment">//在左子树中递归查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(bt-&gt;rchild,k);  <span class="comment">//在右子树中递归查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树中查找的非递归算法</span></span><br><span class="line">BSTNode *<span class="title function_">SearchBST_unr</span><span class="params">(BSTNode *bt,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k==bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> bt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;bt-&gt;key)</span><br><span class="line">            bt=bt-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bt=bt-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除二叉搜索树中的一个节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteBST</span><span class="params">(BSTNode *bt, KeyType k)</span>  <span class="comment">//在bt中删除关键字为k的结点</span></span><br><span class="line">&#123;   </span><br><span class="line">    BSTNode *tmpchild,*p;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt-&gt;key != k)</span><br><span class="line">        &#123;</span><br><span class="line">            p = bt;                             <span class="comment">//  记录目标节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; bt-&gt;key)                     <span class="comment">//  往左找</span></span><br><span class="line">                bt = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; bt-&gt;key)               <span class="comment">//  往右找</span></span><br><span class="line">                bt = bt-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;rchild == <span class="literal">NULL</span>)                  <span class="comment">//  目标节点无右孩子节点，则目标节点可能有左节点（左节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span>)             <span class="comment">//  目标节点无左孩子节点，则目标节点可能有右节点（右节点可能为NULL）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; p-&gt;key)                     <span class="comment">//   目标节点在左子树</span></span><br><span class="line">                p-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; p-&gt;key)               <span class="comment">//    目标节点在右子树</span></span><br><span class="line">                p-&gt;rchild = bt-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">//  目标节点有左右孩子节点，找到左子树的最大的右孩子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpchild = bt-&gt;lchild;              <span class="comment">//  左子树节点</span></span><br><span class="line">            <span class="keyword">if</span>(tmpchild-&gt;rchild == <span class="literal">NULL</span>)        <span class="comment">//  当左子树没有右孩子节点，则左子树节点就是 用来替换目标节点的 最大节点，</span></span><br><span class="line">            &#123;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;</span><br><span class="line">                bt-&gt;lchild = tmpchild-&gt;lchild;   <span class="comment">//  删除左子树节点，此时左子树节点没有右孩子节点，可能有左孩子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//  左子树节点有右孩子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (tmpchild-&gt;rchild != <span class="literal">NULL</span>)    <span class="comment">//  找到最大深度的右孩子节点，就是值最大的节点，并且记录它的父节点</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    p = tmpchild;</span><br><span class="line">                    tmpchild = tmpchild-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                bt-&gt;key = tmpchild-&gt;key;            <span class="comment">//  替换目标节点的值</span></span><br><span class="line">                p-&gt;rchild = tmpchild-&gt;lchild;       <span class="comment">//  此时的 tmpchild 一定没有右子节点，但可能有左子节点</span></span><br><span class="line">                <span class="built_in">free</span>(tmpchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2020/07/19/leetcode-04.02/">leetcode 面试题 04.02e. 最小高度树</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">Published on: <time datetime="2020-07-19T02:00:00.000Z" itemprop="datePublished">Jul 19, 2020</time>
</div>
      <div class="tags">Tags: 

<a href="/tags/leetcode/">leetcode</a>
</div>
    </div>
      
        <h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">          0 </span><br><span class="line">         / \ </span><br><span class="line">       -3   9 </span><br><span class="line">       /   / </span><br><span class="line">     -10  5 </span><br></pre></td></tr></table></figure>


<h3><span id="suan-fa">算法</span><a href="#suan-fa" class="header-anchor">#</a></h3><p>已知有一个升序 有序的 整数数组，要构造一棵高度最小的二叉搜索树。</p>
<p>根据二叉搜索树的定义可知：分支节点上的值大于左子树上节点的值，小于右子树上节点的值，且二叉搜索树上的没有健值相等的节点。</p>
<p>高度最小则需要符合完全二叉树的特点。</p>
<p>因此可以使用 递归+二分法 从整数数组里逐个取出节点，构成一个二叉树。</p>
<h3><span id="di-gui-er-fen-fa">递归+二分法</span><a href="#di-gui-er-fen-fa" class="header-anchor">#</a></h3><p>递归+二分法 的重点在于边界值的确定。</p>
<ol>
<li>[0,numsSize-1]</li>
</ol>
<p>左右边界值分别是数组开始索引的和结束索引，每次取出中间值后，数组分成了三部分：[0,mid-1],mid,[mid+1,numsSize-1]。再分别对左右两个数组递归调用。结束递归的条件是数组的左边索引值 $l$ <strong>大于</strong> 右边索引值 $r$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray_2</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray_2(nums, l, mid<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = recursionsortedarray_2(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>[0,numsSize]</li>
</ol>
<p>左右边界值分别是数组开始索引的和数组数量，每次取出中间值后，数组分成了三部分：[0,mid],mid,[mid+1,numsSize]。再分别对左右两个数组递归调用。结束递归的条件是数组的左边索引值 $l$ <strong>大于等于</strong> 右边索引值 $r$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray(nums, l, mid);</span><br><span class="line">    root-&gt;right = recursionsortedarray(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法都可以得到一个高度 $h$ 一样的二叉树，但是第一种的到的结果不符合完成二叉树，所以应该采用第二种边界值方法。</p>
<img src="http://tva4.sinaimg.cn/large/7d4c6366gy1ggwexsuchfj21jb267n5m.jpg" width="700" align="bottom">

<h3><span id="c-dai-ma">C代码</span><a href="#c-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> TreeNode *<span class="title function_">creatnewnode</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;val = num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">recursionsortedarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span>  creatnewnode(nums[mid]);</span><br><span class="line">    root-&gt;left = recursionsortedarray(nums, l, mid);</span><br><span class="line">    root-&gt;right = recursionsortedarray(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> recursionsortedarray(nums, <span class="number">0</span>, numsSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left != <span class="literal">NULL</span> || T-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                disTree(T-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                disTree(T-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numsSize = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">T</span> =</span> sortedArrayToBST(nums,numsSize);</span><br><span class="line">    disTree(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
	</div>

<div class="meta">
	
</div>
</article>


  <nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/page/3/" class="next">Next</a>
    
  <div class="center"><a href="/archives/index.html">Blog Archives</a></div>
  </nav>


    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2022

    CFONG
. Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> |
    Theme is <a target="_blank" rel="noopener" href="https://github.com/wd/hexo-fabric">hexo-fabric</a>, fork from <a target="_blank" rel="noopener" href="http://github.com/panks/fabric">fabric</a> by <a target="_blank" rel="noopener" href="http://panks.me">Pankaj Kumar</a>
</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
